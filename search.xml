<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[YYModel源码分析]]></title>
      <url>http://ChenAo0727.github.io/2017/01/03/YYModel/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>YYModel 是一个iOS JSON模型转化库，和其他一些同类型库相比，具有比较好的性能优势。本文会对YYModel的源码进行分析，具体用法作者ibireme在<a href="https://github.com/ibireme/YYModel" target="_blank" rel="external">github</a>中有提及。YYModel的目录结构很简单，只有两个类, <code>NSObject+YYModel</code> 和 <code>YYClassInfo</code>。<code>YYClassInfo</code>主要对根类NSObject 的 <code>Ivar</code> , <code>Method</code>, <code>Property</code>以及<code>Class</code>本身进行了封装，<code>NSObject+YYModel</code> 是 NSObject的分类，扩展了一些JSON模型转化的方法。</p>
<h2 id="YYClassInfo"><a href="#YYClassInfo" class="headerlink" title="YYClassInfo"></a>YYClassInfo</h2><h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><blockquote>
<p> YYClassIvarInfo : 对 Class的Ivar进行了封装<br> YYClassMethodInfo : 对 Class的Method进行了封装<br> YYClassPropertyInfo :  对 Class的Property进行了封装<br> YYClassInfo :  对Class进行了封装，包含了YYClassIvarInfo，YYClassMethodInfo，YYClassPropertyInfo</p>
</blockquote>
<h3 id="变量类型编码"><a href="#变量类型编码" class="headerlink" title="变量类型编码"></a>变量类型编码</h3><p>说到变量，可能我们写代码中最常见的就是变量了。当我们自定义一个类时，首先总是会申明一些属性，而且每个属性都会带有一些修饰词。比如是否原子性，内存管理原则，只读性。这些都可以通过这个属性的<code>property_getAttributes</code> 方法获取，苹果为所有的类型，包括属性类型都有编码，具体可以查看<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="external">苹果官方文档:类型编码</a>, <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html" target="_blank" rel="external">苹果官方文档:属性类型</a>。 下面是一个简单例子：</p>
<ol>
<li>申明属性</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@interface Cat : NSObject</div><div class="line">@end</div><div class="line"></div><div class="line">@interface Person : NSObject</div><div class="line">@property (nonatomic,copy) NSString *name;</div><div class="line">@property (nonatomic,assign) NSInteger age;</div><div class="line">@property (nonatomic,strong) Cat *cat;</div><div class="line">- (NSDictionary *)getProperties;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>2.通过runtime 来获取所有属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#import &quot;Person.h&quot;</div><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line">@implementation Person</div><div class="line">- (NSDictionary *) getProperties&#123;</div><div class="line">    NSMutableDictionary *dic = [NSMutableDictionary dictionary];</div><div class="line">    unsigned int count = 0;</div><div class="line">    objc_property_t *propertyList = class_copyPropertyList([self class], &amp;count);</div><div class="line">    for (NSUInteger  i = 0; i &lt; count; i++) &#123;</div><div class="line">        const char *name = property_getName(propertyList[i]);</div><div class="line">        const char *attribute = property_getAttributes(propertyList[i]);</div><div class="line">        NSString *nameStr = [NSString stringWithUTF8String:name];</div><div class="line">        NSString *attributeStr = [NSString stringWithUTF8String:attribute];</div><div class="line">        dic[nameStr] = attributeStr;</div><div class="line">    &#125;</div><div class="line">    return [dic copy];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>3.打印结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">2017-01-03 10:54:34.690 Properties[16941:881462] &#123;</div><div class="line">    age = &quot;Tq,N,V_age&quot;;</div><div class="line">    cat = &quot;T@\&quot;Cat\&quot;,&amp;,N,V_cat&quot;;</div><div class="line">    name = &quot;T@\&quot;NSString\&quot;,C,N,V_name&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到属性的所有类型编码信息，其中第一个代表是这个变量的类型，以T开头，最后一个代表的是变量的名字，一般用V_属性名表示，中间的部分就是我们声明的修饰符。比如age的类型是 Tq，而在官方文档中q 代表了<code>A long long</code>,64bit下NSInteger的取值范围就是long == long long ，N代表了非原子性，变量名是_age。其他的@代表了OC类型 <code>id</code> ,cat类型即是T@”Cat”，&amp;代表了 这个变量是retain （ARC下strong相当于retain），C 代表了copy</p>
<h3 id="YYEncodingType"><a href="#YYEncodingType" class="headerlink" title="YYEncodingType"></a>YYEncodingType</h3><p>根据类型编码自定义了类型枚举，包含了三个部分</p>
<blockquote>
<p>YYEncodingTypeMask : 0~8位的值，变量的数据类型<br>YYEncodingTypeQualifierMask : 8~16位的值，变量的方法类型<br>YYEncodingTypePropertyMask: 16~24位的值，变量的属性类型</p>
</blockquote>
<p>这里把枚举值分成三个部分，通过 枚举值 &amp;  对应 Mask 取出对应的变量类型，区分不同类型部分。<code>YYEncodingGetType</code> 是根据变量的数据类型编码值获取自定义<code>YYEncodingType</code></p>
<h3 id="Var-Method-Property"><a href="#Var-Method-Property" class="headerlink" title="Var Method Property"></a>Var Method Property</h3><blockquote>
<p>YYClassIvarInfo：用于存取变量的信息</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> Instance variable information.</div><div class="line"> */</div><div class="line">@interface YYClassIvarInfo : NSObject</div><div class="line">@property (nonatomic, assign, readonly) Ivar ivar;              ///&lt; ivar opaque struct</div><div class="line">@property (nonatomic, strong, readonly) NSString *name;         ///&lt; Ivar&apos;s name</div><div class="line">@property (nonatomic, assign, readonly) ptrdiff_t offset;       ///&lt; Ivar&apos;s offset</div><div class="line">@property (nonatomic, strong, readonly) NSString *typeEncoding; ///&lt; Ivar&apos;s type encoding</div><div class="line">@property (nonatomic, assign, readonly) YYEncodingType type;    ///&lt; Ivar&apos;s type</div><div class="line"></div><div class="line">/**</div><div class="line"> Creates and returns an ivar info object.</div><div class="line"> </div><div class="line"> @param ivar ivar opaque struct</div><div class="line"> @return A new object, or nil if an error occurs.</div><div class="line"> */</div><div class="line">- (instancetype)initWithIvar:(Ivar)ivar;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>Ivar是表示实例变量的类型，其实际是一个指向objc_ivar结构体的指针，其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">struct objc_ivar &#123;  </div><div class="line">    charchar *ivar_name                              OBJC2_UNAVAILABLE;  </div><div class="line">    charchar *ivar_type                              OBJC2_UNAVAILABLE;  </div><div class="line">    int ivar_offset                                  OBJC2_UNAVAILABLE;  </div><div class="line">#ifdef __LP64__  </div><div class="line">    int space                                        OBJC2_UNAVAILABLE;  </div><div class="line">#endif  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 运用runtime,<code>name</code>通过的<code>ivar_getName</code>获取，<code>offset</code>  通过<code>ivar_getOffset</code>获取，<code>typeEncoding</code> 通过 <code>ivar_getTypeEncoding</code> 获取，<code>type</code> 通过自定义方法 <code>YYEncodingGetType</code>获取。其中<code>offset</code>是变量的基地址偏移量，可以通过它来直接访问变量数据,下面是例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">    Person *p = [[Person alloc]init];</div><div class="line">//    NSLog(@&quot;%@&quot;,[p getProperties]);</div><div class="line">    p.age = 20;</div><div class="line">    Ivar age_ivar = class_getInstanceVariable([Person class], &quot;_age&quot;);</div><div class="line">    long *age_pointer = (long *)((__bridge void  *)(p) + ivar_getOffset(age_ivar));</div><div class="line">    NSLog(@&quot;age ivar offset = %td&quot;, ivar_getOffset(age_ivar));</div><div class="line">    *age_pointer = 10;</div><div class="line">    NSLog(@&quot;%@&quot;, p);</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (NSString *)description &#123;</div><div class="line">    NSLog(@&quot;current pointer = %p&quot;, self);</div><div class="line">    NSLog(@&quot;age pointer = %p&quot;, &amp;_age);</div><div class="line">    return [NSString stringWithFormat:@&quot;age = %zi&quot;, _age];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">2017-01-03 14:41:14.175 Properties[20934:1554728] age ivar offset = 16</div><div class="line">2017-01-03 14:41:14.176 Properties[20934:1554728] current pointer = 0x600000075140</div><div class="line">2017-01-03 14:41:14.176 Properties[20934:1554728] age pointer = 0x600000075150</div><div class="line">2017-01-03 14:41:14.177 Properties[20934:1554728] age = 10</div></pre></td></tr></table></figure>
<blockquote>
<p>YYClassMethodInfo：用于存取方法的信息</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> Method information.</div><div class="line"> */</div><div class="line">@interface YYClassMethodInfo : NSObject</div><div class="line">@property (nonatomic, assign, readonly) Method method;                  ///&lt; method opaque struct</div><div class="line">@property (nonatomic, strong, readonly) NSString *name;                 ///&lt; method name</div><div class="line">@property (nonatomic, assign, readonly) SEL sel;                        ///&lt; method&apos;s selector</div><div class="line">@property (nonatomic, assign, readonly) IMP imp;                        ///&lt; method&apos;s implementation</div><div class="line">@property (nonatomic, strong, readonly) NSString *typeEncoding;         ///&lt; method&apos;s parameter and return types</div><div class="line">@property (nonatomic, strong, readonly) NSString *returnTypeEncoding;   ///&lt; return value&apos;s type</div><div class="line">@property (nullable, nonatomic, strong, readonly) NSArray&lt;NSString *&gt; *argumentTypeEncodings; ///&lt; array of arguments&apos; type</div><div class="line"></div><div class="line">/**</div><div class="line"> Creates and returns a method info object.</div><div class="line"> </div><div class="line"> @param method method opaque struct</div><div class="line"> @return A new object, or nil if an error occurs.</div><div class="line"> */</div><div class="line">- (instancetype)initWithMethod:(Method)method;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p><code>Method</code> 的信息同 <code>Ivar</code> 一样，通过runtime的 method相关方法获取，其他的一些信息同<code>Ivar</code>，主要来说一下 <code>SEL</code>和 <code>Imp</code></p>
<blockquote>
<p>SEL: 方法ID，C字符串</p>
</blockquote>
<p><code>typedef struct objc_selector *SEL;</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/// Defines a method</div><div class="line">struct objc_method_description &#123;</div><div class="line">	SEL name;               /**&lt; The name of the method */</div><div class="line">	char *types;            /**&lt; The types of the method arguments */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<blockquote>
<p>IMP：方法函数指针 </p>
</blockquote>
<p>OC是动态语言，方法调用（也叫做消息发送）是在运行时动态绑定的，而非编译时。如何做到正确的调用指定的方法呢？这里就需要用到SEL和IMP。编译器会将消息发送转换成对<code>objc_msgSend(void /* id self, SEL op, ... */ )</code>方法的调用 。<code>objc_msgSend</code>方法根据对象的isa指针找到对象的类，通过在类中的调度表（dispatch table）中查找SEL 获得 IMP,精确执行指定方法。</p>
<blockquote>
<p>YYClassPropertyInfo: 用于存取属性的信息</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> Property information.</div><div class="line"> */</div><div class="line">@interface YYClassPropertyInfo : NSObject</div><div class="line">@property (nonatomic, assign, readonly) objc_property_t property; ///&lt; property&apos;s opaque struct</div><div class="line">@property (nonatomic, strong, readonly) NSString *name;           ///&lt; property&apos;s name</div><div class="line">@property (nonatomic, assign, readonly) YYEncodingType type;      ///&lt; property&apos;s type</div><div class="line">@property (nonatomic, strong, readonly) NSString *typeEncoding;   ///&lt; property&apos;s encoding value</div><div class="line">@property (nonatomic, strong, readonly) NSString *ivarName;       ///&lt; property&apos;s ivar name</div><div class="line">@property (nullable, nonatomic, assign, readonly) Class cls;      ///&lt; may be nil</div><div class="line">@property (nullable, nonatomic, strong, readonly) NSArray&lt;NSString *&gt; *protocols; ///&lt; may nil</div><div class="line">@property (nonatomic, assign, readonly) SEL getter;               ///&lt; getter (nonnull)</div><div class="line">@property (nonatomic, assign, readonly) SEL setter;               ///&lt; setter (nonnull)</div><div class="line"></div><div class="line">/**</div><div class="line"> Creates and returns a property info object.</div><div class="line"> </div><div class="line"> @param property property opaque struct</div><div class="line"> @return A new object, or nil if an error occurs.</div><div class="line"> */</div><div class="line">- (instancetype)initWithProperty:(objc_property_t)property;</div><div class="line">@end</div></pre></td></tr></table></figure>
<blockquote>
<p>YYClassInfo: 对Class的封装，包含了上面三部分的信息</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> Class information for a class.</div><div class="line"> */</div><div class="line">@interface YYClassInfo : NSObject</div><div class="line">@property (nonatomic, assign, readonly) Class cls; ///&lt; class object</div><div class="line">@property (nullable, nonatomic, assign, readonly) Class superCls; ///&lt; super class object</div><div class="line">@property (nullable, nonatomic, assign, readonly) Class metaCls;  ///&lt; class&apos;s meta class object</div><div class="line">@property (nonatomic, readonly) BOOL isMeta; ///&lt; whether this class is meta class</div><div class="line">@property (nonatomic, strong, readonly) NSString *name; ///&lt; class name</div><div class="line">@property (nullable, nonatomic, strong, readonly) YYClassInfo *superClassInfo; ///&lt; super class&apos;s class info</div><div class="line">@property (nullable, nonatomic, strong, readonly) NSDictionary&lt;NSString *, YYClassIvarInfo *&gt; *ivarInfos; ///&lt; ivars</div><div class="line">@property (nullable, nonatomic, strong, readonly) NSDictionary&lt;NSString *, YYClassMethodInfo *&gt; *methodInfos; ///&lt; methods</div><div class="line">@property (nullable, nonatomic, strong, readonly) NSDictionary&lt;NSString *, YYClassPropertyInfo *&gt; *propertyInfos; ///&lt; properties</div></pre></td></tr></table></figure>
<h3 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h3><p>其中有<code>metaCls</code>代表了元类。那什么是元类呢？下面是一张经典的类结构图</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1618300-fd7b658a12d7bcee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="isa.png"></p>
<p>在OC中，每个实例对象都有一个isa指针，它指向了对象的class。而这个class也同样有一个isa指针，它就是指向了它的元类，其实类也是一个对象，所以对象之于类的关系，就相当于类（类对象）之于其元类（类对象的类）的关系。那元类有什么用呢？我们都知道在OC中调用方法有实例方法和类方法。我们调用实例方法，就是通过isa指针找到指定的class，查找存储在class中的方法列表执行方法，所以元类的作用就是调用类方法时，通过查找保存在元类中的类方法执行方法的作用。那为什么不把所有方法都保存在类中，可能这样更加高效也节省资源吧，具体可以自己查找资料。</p>
<p>在YYClassInfo中，有一个<code>_update</code>方法，用来更新类中存储的信息。</p>
<h3 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)classInfoWithClass:(Class)cls &#123;</div><div class="line">    if (!cls) return nil;</div><div class="line">    static CFMutableDictionaryRef classCache;</div><div class="line">    static CFMutableDictionaryRef metaCache;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    static dispatch_semaphore_t lock;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        classCache = CFDictionaryCreateMutable(CFAllocatorGetDefault(), 0, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks);</div><div class="line">        metaCache = CFDictionaryCreateMutable(CFAllocatorGetDefault(), 0, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks);</div><div class="line">        lock = dispatch_semaphore_create(1);</div><div class="line">    &#125;);</div><div class="line">    dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);</div><div class="line">    YYClassInfo *info = CFDictionaryGetValue(class_isMetaClass(cls) ? metaCache : classCache, (__bridge const void *)(cls));</div><div class="line">    if (info &amp;&amp; info-&gt;_needUpdate) &#123;</div><div class="line">        [info _update];</div><div class="line">    &#125;</div><div class="line">    dispatch_semaphore_signal(lock);</div><div class="line">    if (!info) &#123;</div><div class="line">        info = [[YYClassInfo alloc] initWithClass:cls];</div><div class="line">        if (info) &#123;</div><div class="line">            dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);</div><div class="line">            CFDictionarySetValue(info.isMeta ? metaCache : classCache, (__bridge const void *)(cls), (__bridge const void *)(info));</div><div class="line">            dispatch_semaphore_signal(lock);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return info;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>要点:</strong></p>
<ul>
<li><p>CFDictionaryCreateMutable 和  CFDictionarySetValue 不是线程安全的，所以需要创建锁，采用 <code>dispatch_semaphore</code> 通过控制信号量实现了锁</p>
</li>
<li><p>设置缓存，如果在缓存中存在class，则直接获取到对应的ivar，method，property，否者创建YYClassInfo实例对象</p>
</li>
</ul>
<h2 id="NSObject-YYModel"><a href="#NSObject-YYModel" class="headerlink" title="NSObject+YYModel:"></a>NSObject+YYModel:</h2><p><code>NSObject+YYModel</code>是YYModel的核心类，主要部分：</p>
<blockquote>
<p>强制内联C函数：功能函数<br>私有类_YYModelPropertyMeta : 管理Model属性的数据, 类型, 映射的key，keyPath<br>私有类 _YYModelMeta :管理Model 数据,类型,存储 映射key,keypath，_YYModelPropertyMeta<br>NSObject NSArray NSDictionary (YYModel) : 几个分类，YYModel主体功能实现<br>YYModel 协议：扩展功能实现</p>
</blockquote>
<h3 id="私有类-YYModelPropertyMeta"><a href="#私有类-YYModelPropertyMeta" class="headerlink" title="私有类_YYModelPropertyMeta"></a>私有类_YYModelPropertyMeta</h3><p><code>_YYModelPropertyMeta</code>是对上面的 <code>YYClassPropertyInfo</code> 的进一步封装。</p>
<h4 id="内部实例变量"><a href="#内部实例变量" class="headerlink" title="内部实例变量"></a>内部实例变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">/// A property info in object model.</div><div class="line">// model property的进一步分装</div><div class="line">@interface _YYModelPropertyMeta : NSObject &#123;</div><div class="line">    @package</div><div class="line">    NSString *_name;              //属性名</div><div class="line">    YYEncodingType _type;         //属性的编码类型</div><div class="line">    YYEncodingNSType _nsType;     //属性的Foundation类型</div><div class="line">    BOOL _isCNumber;              //是否c语言的数字</div><div class="line">    Class _cls;                   //属性的class</div><div class="line">    Class _genericCls;    //属性内包含的类class</div><div class="line">    SEL _getter;             //属性 getter方法</div><div class="line">    SEL _setter;             //属性 setter方法</div><div class="line">    BOOL _isKVCCompatible;     //是否可以使用KVC</div><div class="line">    BOOL _isStructAvailableForKeyedArchiver;   //是否struct并且可以归档</div><div class="line">    BOOL _hasCustomClassFromDictionary;   //是否包含本本地的class转换</div><div class="line">    /*</div><div class="line">     property-&gt;key:     </div><div class="line">   _mappedToKey:key   _mappedToKeyPath:nil   _mappedToKeyArray:nil</div><div class="line">     property-&gt;keyPath:  </div><div class="line">   _mappedToKey:keyPath _mappedToKeyPath:keyPath(array)  _mappedToKeyArray:nil</div><div class="line">     property-&gt;keys:   </div><div class="line">   _mappedToKey:keys[0] _mappedToKeyPath:nil/keyPath        _mappedToKeyArray:keys(array)</div><div class="line">     */</div><div class="line">    NSString *_mappedToKey;     //属性名映射的 key </div><div class="line">    NSArray *_mappedToKeyPath;  //属性名映射的 keyPath </div><div class="line">    NSArray *_mappedToKeyArray;  //属性名的映射的key keyPath 数组 </div><div class="line">    YYClassPropertyInfo *_info;  //属性的YYClassPropertyInfo info</div><div class="line">    _YYModelPropertyMeta *_next;  </div><div class="line">    //多个属性名映射到同一个key 时，指向下一个属性名的YYModelPropertyMeta 指针</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>主要是最后几个变量。其中<code>_mappedToKey</code> <code>_mappedToKeyPath</code> <code>_mappedToKeyArray</code> 是属性映射的key，keyPath ，key (keypath) 数组<code>_mappedToKeyArray</code> 中可以是key和keyPath，实际取其中第一个映射到的值</p>
<p>一般一个属性名对应一个key值，如果多个属性名对应同一个key，这里就需要next发挥作用了。比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    @&quot;name1&quot; : @&quot;name&quot;,</div><div class="line">    @&quot;name2&quot; : @&quot;name&quot;,</div><div class="line">    @&quot;name3&quot; : @&quot;name&quot;,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先name1最先得到映射，对mapKey进行赋值，取得json中的name字段进行赋值一系列操作，此时next指针为nil<br>name2接着进行映射，对mapKey进行赋值，接着取得原来json key对应的属性描述对象，将name2的next指针，指向name1。<br>name3接着进行映射，对mapKey进行赋值，接着取得原来json key对应的属性描述对象，将name3的next指针，指向name2。</p>
<p><strong>代码中的实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">propertyMeta-&gt;_next = mapper[mappedToKey] ?: nil;</div><div class="line">mapper[mappedToKey] = propertyMeta;</div></pre></td></tr></table></figure>
<h4 id="初始化方法-1"><a href="#初始化方法-1" class="headerlink" title="初始化方法"></a>初始化方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div></pre></td><td class="code"><pre><div class="line">@implementation _YYModelPropertyMeta</div><div class="line">+ (instancetype)metaWithClassInfo:(YYClassInfo *)classInfo propertyInfo:(YYClassPropertyInfo *)propertyInfo generic:(Class)generic &#123;</div><div class="line">    //创建并且根据propertyInfo 进行变量赋值</div><div class="line">    _YYModelPropertyMeta *meta = [self new];</div><div class="line">    meta-&gt;_name = propertyInfo.name;</div><div class="line">    meta-&gt;_type = propertyInfo.type;</div><div class="line">    meta-&gt;_info = propertyInfo;</div><div class="line"></div><div class="line">    // 属性为容器类型的时候， 映射类型赋值</div><div class="line">    meta-&gt;_genericCls = generic;</div><div class="line"></div><div class="line">    if ((meta-&gt;_type &amp; YYEncodingTypeMask) == YYEncodingTypeObject) &#123; </div><div class="line">         // 是否Foundation 类型</div><div class="line">        meta-&gt;_nsType = YYClassGetNSType(propertyInfo.cls);</div><div class="line">    &#125; else &#123; </div><div class="line">        // 是否C数据类型</div><div class="line">        meta-&gt;_isCNumber = YYEncodingTypeIsCNumber(meta-&gt;_type);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 属性为结构体类型</div><div class="line">    if ((meta-&gt;_type &amp; YYEncodingTypeMask) == YYEncodingTypeStruct) &#123;</div><div class="line">        /*</div><div class="line">         It seems that NSKeyedUnarchiver cannot decode NSValue except these structs:</div><div class="line">         */</div><div class="line">        static NSSet *types = nil;</div><div class="line">        static dispatch_once_t onceToken;</div><div class="line">        // 单例 创建C结构体类型映射</div><div class="line">        dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">            NSMutableSet *set = [NSMutableSet new];</div><div class="line">            // 32 bit</div><div class="line">            [set addObject:@&quot;&#123;CGSize=ff&#125;&quot;];</div><div class="line">            [set addObject:@&quot;&#123;CGPoint=ff&#125;&quot;];</div><div class="line">            [set addObject:@&quot;&#123;CGRect=&#123;CGPoint=ff&#125;&#123;CGSize=ff&#125;&#125;&quot;];</div><div class="line">            [set addObject:@&quot;&#123;CGAffineTransform=ffffff&#125;&quot;];</div><div class="line">            [set addObject:@&quot;&#123;UIEdgeInsets=ffff&#125;&quot;];</div><div class="line">            [set addObject:@&quot;&#123;UIOffset=ff&#125;&quot;];</div><div class="line">            // 64 bit</div><div class="line">            [set addObject:@&quot;&#123;CGSize=dd&#125;&quot;];</div><div class="line">            [set addObject:@&quot;&#123;CGPoint=dd&#125;&quot;];</div><div class="line">            [set addObject:@&quot;&#123;CGRect=&#123;CGPoint=dd&#125;&#123;CGSize=dd&#125;&#125;&quot;];</div><div class="line">            [set addObject:@&quot;&#123;CGAffineTransform=dddddd&#125;&quot;];</div><div class="line">            [set addObject:@&quot;&#123;UIEdgeInsets=dddd&#125;&quot;];</div><div class="line">            [set addObject:@&quot;&#123;UIOffset=dd&#125;&quot;];</div><div class="line">            types = set;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        // 只有上面结构体才能被归档</div><div class="line">        if ([types containsObject:propertyInfo.typeEncoding]) &#123;</div><div class="line">            meta-&gt;_isStructAvailableForKeyedArchiver = YES;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 设置class类型</div><div class="line">    meta-&gt;_cls = propertyInfo.cls;</div><div class="line"></div><div class="line">    // 如果是容器类型</div><div class="line">    if (generic) &#123;</div><div class="line">        // 从容器class 中读取</div><div class="line">        meta-&gt;_hasCustomClassFromDictionary = [generic respondsToSelector:@selector(modelCustomClassForDictionary:)];</div><div class="line">    &#125; else if (meta-&gt;_cls &amp;&amp; meta-&gt;_nsType == YYEncodingTypeNSUnknown) &#123;</div><div class="line">        // 从class类型中读取</div><div class="line">        meta-&gt;_hasCustomClassFromDictionary = [meta-&gt;_cls respondsToSelector:@selector(modelCustomClassForDictionary:)];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 设置 getter 和 setter 方法</div><div class="line">    if (propertyInfo.getter) &#123;</div><div class="line">        if ([classInfo.cls instancesRespondToSelector:propertyInfo.getter]) &#123;</div><div class="line">            meta-&gt;_getter = propertyInfo.getter;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (propertyInfo.setter) &#123;</div><div class="line">        if ([classInfo.cls instancesRespondToSelector:propertyInfo.setter]) &#123;</div><div class="line">            meta-&gt;_setter = propertyInfo.setter;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     *  只有实现了getter和setter方法 才能实现归档</div><div class="line">     */</div><div class="line">    if (meta-&gt;_getter &amp;&amp; meta-&gt;_setter) &#123;</div><div class="line">        /*</div><div class="line">        类型是否支持 KVC</div><div class="line">         */</div><div class="line">        switch (meta-&gt;_type &amp; YYEncodingTypeMask) &#123;</div><div class="line">            case YYEncodingTypeBool:</div><div class="line">            case YYEncodingTypeInt8:</div><div class="line">            case YYEncodingTypeUInt8:</div><div class="line">            case YYEncodingTypeInt16:</div><div class="line">            case YYEncodingTypeUInt16:</div><div class="line">            case YYEncodingTypeInt32:</div><div class="line">            case YYEncodingTypeUInt32:</div><div class="line">            case YYEncodingTypeInt64:</div><div class="line">            case YYEncodingTypeUInt64:</div><div class="line">            case YYEncodingTypeFloat:</div><div class="line">            case YYEncodingTypeDouble:</div><div class="line">            case YYEncodingTypeObject:</div><div class="line">            case YYEncodingTypeClass:</div><div class="line">            case YYEncodingTypeBlock:</div><div class="line">            case YYEncodingTypeStruct:</div><div class="line">            case YYEncodingTypeUnion: &#123;</div><div class="line">                meta-&gt;_isKVCCompatible = YES;</div><div class="line">            &#125; break;</div><div class="line">            default: break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return meta;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="私有类-YYModelMeta"><a href="#私有类-YYModelMeta" class="headerlink" title="私有类_YYModelMeta"></a>私有类_YYModelMeta</h3><p><code>_YYModelMeta</code> 是对 <code>YYClassInfo</code> 的再次封装</p>
<h4 id="内部变量"><a href="#内部变量" class="headerlink" title="内部变量"></a>内部变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@interface _YYModelMeta : NSObject &#123;</div><div class="line">    @package</div><div class="line">    YYClassInfo *_classInfo;</div><div class="line"></div><div class="line">    // key: 映射的 json key ,keyPath  value： _YYModelPropertyMeta </div><div class="line">    NSDictionary *_mapper;</div><div class="line"></div><div class="line">    // model所有属性的PropertyMetas</div><div class="line">    NSArray *_allPropertyMetas;</div><div class="line"></div><div class="line">    //model所有映射son keyPath 属性 的PropertyMetas</div><div class="line">    NSArray *_keyPathPropertyMetas;</div><div class="line"></div><div class="line">    // model所有映射多个key 属性 的PropertyMetas</div><div class="line">    NSArray *_multiKeysPropertyMetas;</div><div class="line">    /// 需要映射的属性总个数</div><div class="line">    NSUInteger _keyMappedCount;</div><div class="line"></div><div class="line">    /// Model对应的Foundation 类型</div><div class="line">    YYEncodingNSType _nsType;</div><div class="line"></div><div class="line">    // 事否实现了自定义的映射关系表 </div><div class="line">    BOOL _hasCustomWillTransformFromDictionary;</div><div class="line">    BOOL _hasCustomTransformFromDictionary;</div><div class="line">    BOOL _hasCustomTransformToDictionary;</div><div class="line">    BOOL _hasCustomClassFromDictionary;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/// Returns the cached model class meta</div><div class="line">+ (instancetype)metaWithClass:(Class)cls &#123;</div><div class="line">    if (!cls) return nil;</div><div class="line">    static CFMutableDictionaryRef cache;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    static dispatch_semaphore_t lock;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        cache = CFDictionaryCreateMutable(CFAllocatorGetDefault(), 0, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks);</div><div class="line">        lock = dispatch_semaphore_create(1);</div><div class="line">    &#125;);</div><div class="line">    dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);</div><div class="line">    _YYModelMeta *meta = CFDictionaryGetValue(cache, (__bridge const void *)(cls));</div><div class="line">    dispatch_semaphore_signal(lock);</div><div class="line">    if (!meta || meta-&gt;_classInfo.needUpdate) &#123;</div><div class="line">        meta = [[_YYModelMeta alloc] initWithClass:cls];</div><div class="line">        if (meta) &#123;</div><div class="line">            dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);</div><div class="line">            CFDictionarySetValue(cache, (__bridge const void *)(cls), (__bridge const void *)(meta));</div><div class="line">            dispatch_semaphore_signal(lock);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return meta;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先从缓存中加载，没有在根据传入cls 创建meta，并做缓存处理， dispatch_semaphore 确保线程安全</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div></pre></td><td class="code"><pre><div class="line">@implementation _YYModelMeta</div><div class="line"></div><div class="line"></div><div class="line">- (instancetype)initWithClass:(Class)cls &#123;</div><div class="line"></div><div class="line">    YYClassInfo *classInfo = [YYClassInfo classInfoWithClass:cls];</div><div class="line">    if (!classInfo) return nil;</div><div class="line">    self = [super init];</div><div class="line"></div><div class="line">    // 黑名单 会忽略返回数组里的属性</div><div class="line">    NSSet *blacklist = nil;</div><div class="line">    if ([cls respondsToSelector:@selector(modelPropertyBlacklist)]) &#123;</div><div class="line">        NSArray *properties = [(id&lt;YYModel&gt;)cls modelPropertyBlacklist];</div><div class="line">        if (properties) &#123;</div><div class="line">            blacklist = [NSSet setWithArray:properties];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 白名单 只考虑返回数组内的属性 </div><div class="line">    NSSet *whitelist = nil;</div><div class="line">    if ([cls respondsToSelector:@selector(modelPropertyWhitelist)]) &#123;</div><div class="line">        NSArray *properties = [(id&lt;YYModel&gt;)cls modelPropertyWhitelist];</div><div class="line">        if (properties) &#123;</div><div class="line">            whitelist = [NSSet setWithArray:properties];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 获取容器属性中的映射关系字典</div><div class="line">    NSDictionary *genericMapper = nil;</div><div class="line">   // 判断类中是否实现了对应的modelContainerPropertyGenericClass方法</div><div class="line">    if ([cls respondsToSelector:@selector(modelContainerPropertyGenericClass)]) &#123;</div><div class="line"></div><div class="line">        genericMapper = [(id&lt;YYModel&gt;)cls modelContainerPropertyGenericClass];</div><div class="line">      // 存储key和对应的class到字典中</div><div class="line">        if (genericMapper) &#123;</div><div class="line">            NSMutableDictionary *tmp = [NSMutableDictionary new];</div><div class="line">            [genericMapper enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123;</div><div class="line">                if (![key isKindOfClass:[NSString class]]) return;</div><div class="line">                Class meta = object_getClass(obj);</div><div class="line">                if (!meta) return;</div><div class="line">                if (class_isMetaClass(meta)) &#123;</div><div class="line">                    tmp[key] = obj;</div><div class="line">                &#125; else if ([obj isKindOfClass:[NSString class]]) &#123;</div><div class="line">                    Class cls = NSClassFromString(obj);</div><div class="line">                    if (cls) &#123;</div><div class="line">                        tmp[key] = cls;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;];</div><div class="line">            genericMapper = tmp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 存储所有属性的PropertyMeta对象</div><div class="line"></div><div class="line">    NSMutableDictionary *allPropertyMetas = [NSMutableDictionary new];</div><div class="line">    YYClassInfo *curClassInfo = classInfo;</div><div class="line">    while (curClassInfo &amp;&amp; curClassInfo.superCls != nil) &#123; // recursive parse super class, but ignore root class (NSObject/NSProxy)</div><div class="line">        // 遍历当前ClassInfo 中的所有PropertyInfo， 将它们封装成PropertyMeta</div><div class="line">        for (YYClassPropertyInfo *propertyInfo in curClassInfo.propertyInfos.allValues) &#123;</div><div class="line">            // 检查是否合法和黑白名单筛选</div><div class="line">            if (!propertyInfo.name) continue;</div><div class="line">            if (blacklist &amp;&amp; [blacklist containsObject:propertyInfo.name]) continue;</div><div class="line">            if (whitelist &amp;&amp; ![whitelist containsObject:propertyInfo.name]) continue;</div><div class="line"></div><div class="line">            // 通过propetyInfo来创建PropertyMeta 对象</div><div class="line">            _YYModelPropertyMeta *meta = [_YYModelPropertyMeta metaWithClassInfo:classInfo</div><div class="line">                                                                    propertyInfo:propertyInfo</div><div class="line">                                                                         generic:genericMapper[propertyInfo.name]];</div><div class="line">            // meta name非空</div><div class="line">            if (!meta || !meta-&gt;_name) continue;</div><div class="line">            // 需要实现get方法和set方法</div><div class="line">            if (!meta-&gt;_getter || !meta-&gt;_setter) continue;</div><div class="line">            // 字典中已有该字段的meta 避免重复操作</div><div class="line">            if (allPropertyMetas[meta-&gt;_name]) continue;</div><div class="line">            allPropertyMetas[meta-&gt;_name] = meta;</div><div class="line">        &#125;</div><div class="line">        // 遍历父类的property</div><div class="line">        curClassInfo = curClassInfo.superClassInfo;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    if (allPropertyMetas.count)</div><div class="line">  _allPropertyMetas = allPropertyMetas.allValues.copy;</div><div class="line"></div><div class="line">    // 创建 key ：propertyMeta 映射关系字典</div><div class="line">    NSMutableDictionary *mapper = [NSMutableDictionary new];</div><div class="line">    NSMutableArray *keyPathPropertyMetas = [NSMutableArray new];</div><div class="line">    NSMutableArray *multiKeysPropertyMetas = [NSMutableArray new];</div><div class="line"></div><div class="line">    // 是否实现自定义的映射表</div><div class="line">    if ([cls respondsToSelector:@selector(modelCustomPropertyMapper)]) &#123;</div><div class="line">        </div><div class="line">        NSDictionary *customMapper = [(id &lt;YYModel&gt;)cls modelCustomPropertyMapper];</div><div class="line"></div><div class="line">        // 遍历自定义的字典</div><div class="line">        [customMapper enumerateKeysAndObjectsUsingBlock:^(NSString *propertyName, NSString *mappedToKey, BOOL *stop) &#123;</div><div class="line">           </div><div class="line">            _YYModelPropertyMeta *propertyMeta = allPropertyMetas[propertyName];</div><div class="line">            if (!propertyMeta) return;</div><div class="line">            // 由于用户自定义映射，把原来映射的数据删除</div><div class="line">            [allPropertyMetas removeObjectForKey:propertyName];</div><div class="line"></div><div class="line">            if ([mappedToKey isKindOfClass:[NSString class]]) &#123; </div><div class="line">               // key字段非空</div><div class="line">                if (mappedToKey.length == 0) return;</div><div class="line">                // 保存映射的key</div><div class="line">                propertyMeta-&gt;_mappedToKey = mappedToKey;</div><div class="line"></div><div class="line">                // 如果是keyPath的情况处理</div><div class="line">                NSArray *keyPath = [mappedToKey componentsSeparatedByString:@&quot;.&quot;];</div><div class="line"></div><div class="line">                if (keyPath.count &gt; 1) &#123;  </div><div class="line">                    propertyMeta-&gt;_mappedToKeyPath = keyPath;</div><div class="line">                    [keyPathPropertyMetas addObject:propertyMeta];</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                // 多个属性映射同一个key的时候，用next存储前一个 json Key映射的meta</div><div class="line">                propertyMeta-&gt;_next = mapper[mappedToKey] ?: nil;</div><div class="line">                // 保存新的meta对象</div><div class="line">                mapper[mappedToKey] = propertyMeta;</div><div class="line"></div><div class="line">            &#125; else if ([mappedToKey isKindOfClass:[NSArray class]]) &#123; </div><div class="line"></div><div class="line">         // 一个属性映射多个json Key</div><div class="line"></div><div class="line">                NSMutableArray *mappedToKeyArray = [NSMutableArray new];</div><div class="line">                for (NSString *oneKey in ((NSArray *)mappedToKey)) &#123;</div><div class="line">                    if (![oneKey isKindOfClass:[NSString class]]) continue;</div><div class="line">                    if (oneKey.length == 0) continue;</div><div class="line"></div><div class="line">                    NSArray *keyPath = [oneKey componentsSeparatedByString:@&quot;.&quot;];</div><div class="line">                    if (keyPath.count &gt; 1) &#123;</div><div class="line">                        [mappedToKeyArray addObject:keyPath];</div><div class="line">                    &#125; else &#123;</div><div class="line">                        [mappedToKeyArray addObject:oneKey];</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    if (!propertyMeta-&gt;_mappedToKey) &#123;</div><div class="line">                        propertyMeta-&gt;_mappedToKey = oneKey;</div><div class="line">                        propertyMeta-&gt;_mappedToKeyPath = keyPath.count &gt; 1 ? keyPath : nil;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                if (!propertyMeta-&gt;_mappedToKey) return;</div><div class="line"></div><div class="line">                propertyMeta-&gt;_mappedToKeyArray = mappedToKeyArray;</div><div class="line">                [multiKeysPropertyMetas addObject:propertyMeta];</div><div class="line"></div><div class="line">                propertyMeta-&gt;_next = mapper[mappedToKey] ?: nil;</div><div class="line">                mapper[mappedToKey] = propertyMeta;</div><div class="line">            &#125;</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 没有自定义映射规则的属性处理</div><div class="line"></div><div class="line">    [allPropertyMetas enumerateKeysAndObjectsUsingBlock:^(NSString *name, _YYModelPropertyMeta *propertyMeta, BOOL *stop) &#123;</div><div class="line">        // 直接让mappedKey等于属性名</div><div class="line">        propertyMeta-&gt;_mappedToKey = name;</div><div class="line">        propertyMeta-&gt;_next = mapper[name] ?: nil;</div><div class="line">        mapper[name] = propertyMeta;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    // 变量存储</div><div class="line">    if (mapper.count) _mapper = mapper;</div><div class="line">    if (keyPathPropertyMetas) _keyPathPropertyMetas = keyPathPropertyMetas;</div><div class="line">    if (multiKeysPropertyMetas) _multiKeysPropertyMetas = multiKeysPropertyMetas;</div><div class="line"></div><div class="line">    _classInfo = classInfo;</div><div class="line">    _keyMappedCount = _allPropertyMetas.count;</div><div class="line">    _nsType = YYClassGetNSType(cls);</div><div class="line">    _hasCustomWillTransformFromDictionary = ([cls instancesRespondToSelector:@selector(modelCustomWillTransformFromDictionary:)]);</div><div class="line">    _hasCustomTransformFromDictionary = ([cls instancesRespondToSelector:@selector(modelCustomTransformFromDictionary:)]);</div><div class="line">    _hasCustomTransformToDictionary = ([cls instancesRespondToSelector:@selector(modelCustomTransformToDictionary:)]);</div><div class="line">    _hasCustomClassFromDictionary = ([cls respondsToSelector:@selector(modelCustomClassForDictionary:)]);</div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="JSON-转-Model"><a href="#JSON-转-Model" class="headerlink" title="JSON 转 Model"></a>JSON 转 Model</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)yy_modelWithJSON:(id)son &#123;</div><div class="line">    NSDictionary *dic = [self _yy_dictionaryWithJSON:json];</div><div class="line">    return [self yy_modelWithDictionary:dic];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>传入的json可以是 <code>NSDictionary</code>, <code>NSString</code> , <code>NSData</code>，<code>_yy_dictionaryWithJSON</code> 统一转化成字典</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)yy_modelWithDictionary:(NSDictionary *)dictionary &#123;</div><div class="line">    //字典合法性校验</div><div class="line">    if (!dictionary || dictionary == (id)kCFNull) return nil;</div><div class="line">    if (![dictionary isKindOfClass:[NSDictionary class]]) return nil;</div><div class="line">    </div><div class="line">    Class cls = [self class];</div><div class="line">   //创建 model 元数据</div><div class="line">    _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:cls];</div><div class="line">   //自定义字典</div><div class="line">    if (modelMeta-&gt;_hasCustomClassFromDictionary) &#123;</div><div class="line">        cls = [cls modelCustomClassForDictionary:dictionary] ?: cls;</div><div class="line">    &#125;</div><div class="line">    // 根据dictionary 进行 model 属性赋值</div><div class="line">    NSObject *one = [cls new];</div><div class="line">    if ([one yy_modelSetWithDictionary:dictionary]) return one;</div><div class="line">    return nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结构体 <code>ModelSetContext</code> 存储 modelMeta ，model， dic 作为 <code>CFDictionaryApplyFunction</code> 和 <code>CFArrayApplyFunction</code> 的context 参数，传递数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">- (BOOL)yy_modelSetWithDictionary:(NSDictionary *)dic &#123;</div><div class="line"></div><div class="line">   // 合法性检验</div><div class="line">    if (!dic || dic == (id)kCFNull) return NO;</div><div class="line">    if (![dic isKindOfClass:[NSDictionary class]]) return NO;</div><div class="line">    </div><div class="line"></div><div class="line">    _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:object_getClass(self)];</div><div class="line">    if (modelMeta-&gt;_keyMappedCount == 0) return NO;</div><div class="line">    </div><div class="line">    if (modelMeta-&gt;_hasCustomWillTransformFromDictionary) &#123;</div><div class="line">        dic = [((id&lt;YYModel&gt;)self) modelCustomWillTransformFromDictionary:dic];</div><div class="line">        if (![dic isKindOfClass:[NSDictionary class]]) return NO;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    ModelSetContext context = &#123;0&#125;;</div><div class="line">    context.modelMeta = (__bridge void *)(modelMeta);</div><div class="line">    context.model = (__bridge void *)(self);</div><div class="line">    context.dictionary = (__bridge void *)(dic);</div><div class="line">   </div><div class="line">    if (modelMeta-&gt;_keyMappedCount &gt;= CFDictionaryGetCount((CFDictionaryRef)dic)) &#123;</div><div class="line">        //映射的key Count &gt;= dic Count</div><div class="line">        CFDictionaryApplyFunction((CFDictionaryRef)dic, ModelSetWithDictionaryFunction, &amp;context);</div><div class="line">        if (modelMeta-&gt;_keyPathPropertyMetas) &#123;</div><div class="line">            CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_keyPathPropertyMetas,</div><div class="line">                                 CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta-&gt;_keyPathPropertyMetas)),</div><div class="line">                                 ModelSetWithPropertyMetaArrayFunction,</div><div class="line">                                 &amp;context);</div><div class="line">        &#125;</div><div class="line">        if (modelMeta-&gt;_multiKeysPropertyMetas) &#123;</div><div class="line">            CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_multiKeysPropertyMetas,</div><div class="line">                                 CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta-&gt;_multiKeysPropertyMetas)),</div><div class="line">                                 ModelSetWithPropertyMetaArrayFunction,</div><div class="line">                                 &amp;context);</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">         //映射的key Count &lt; dic Count  </div><div class="line">        CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_allPropertyMetas,</div><div class="line">                             CFRangeMake(0, modelMeta-&gt;_keyMappedCount),</div><div class="line">                             ModelSetWithPropertyMetaArrayFunction,</div><div class="line">                             &amp;context);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (modelMeta-&gt;_hasCustomTransformFromDictionary) &#123;</div><div class="line">        return [((id&lt;YYModel&gt;)self) modelCustomTransformFromDictionary:dic];</div><div class="line">    &#125;</div><div class="line">    return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>   调用CoreFoundation 的   CFDictionaryApplyFunction 和  CFArrayApplyFunction 回调自定义的 Apply function<br><code>static void ModelSetWithDictionaryFunction(const void *_key, const void *_value, void *_context)</code> 和 <code>static void ModelSetWithPropertyMetaArrayFunction(const void *_propertyMeta, void *_context)</code></p>
<p>根据获得的value ，model ，_propertyMeta 最后统一调用 下面方法，运用runtime的 <code>objc_msgSend</code> 设置model属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">static void ModelSetValueForProperty(__unsafe_unretained id model,</div><div class="line">                                     __unsafe_unretained id value,</div><div class="line">                                     __unsafe_unretained _YYModelPropertyMeta *meta)</div></pre></td></tr></table></figure>
<p>自定义的<code>CFDictionaryApplyFunction</code> 的回调方法，CoreFoundation中的原回调函数<br><code>typedef void (*CFDictionaryApplierFunction)(const void *key, const void *value, void *context);</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> Apply function for dictionary, to set the key-value pair to model.</div><div class="line"> </div><div class="line"> @param _key     should not be nil, NSString.</div><div class="line"> @param _value   should not be nil.</div><div class="line"> @param _context _context.modelMeta and _context.model should not be nil.</div><div class="line"> */</div><div class="line">static void ModelSetWithDictionaryFunction(const void *_key, const void *_value, void *_context) &#123;</div><div class="line">    ModelSetContext *context = _context;</div><div class="line">    __unsafe_unretained _YYModelMeta *meta = (__bridge _YYModelMeta *)(context-&gt;modelMeta);</div><div class="line">    __unsafe_unretained _YYModelPropertyMeta *propertyMeta = [meta-&gt;_mapper objectForKey:(__bridge id)(_key)];</div><div class="line">    __unsafe_unretained id model = (__bridge id)(context-&gt;model);</div><div class="line">    while (propertyMeta) &#123;</div><div class="line">        if (propertyMeta-&gt;_setter) &#123;</div><div class="line">            ModelSetValueForProperty(model, (__bridge __unsafe_unretained id)_value, propertyMeta);</div><div class="line">        &#125;</div><div class="line">        propertyMeta = propertyMeta-&gt;_next;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>自定义的<code>CFArrayApplyFunction</code> 的回调方法，CoreFoundation中的原回调函数<br><code>typedef void (*CFArrayApplierFunction)(const void *value, void *context);</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> Apply function for model property meta, to set dictionary to model.</div><div class="line"> </div><div class="line"> @param _propertyMeta should not be nil, _YYModelPropertyMeta.</div><div class="line"> @param _context      _context.model and _context.dictionary should not be nil.</div><div class="line"> */</div><div class="line">static void ModelSetWithPropertyMetaArrayFunction(const void *_propertyMeta, void *_context) &#123;</div><div class="line">    ModelSetContext *context = _context;</div><div class="line">    __unsafe_unretained NSDictionary *dictionary = (__bridge NSDictionary *)(context-&gt;dictionary);</div><div class="line">    __unsafe_unretained _YYModelPropertyMeta *propertyMeta = (__bridge _YYModelPropertyMeta *)(_propertyMeta);</div><div class="line">    if (!propertyMeta-&gt;_setter) return;</div><div class="line">    id value = nil;</div><div class="line">    </div><div class="line">    if (propertyMeta-&gt;_mappedToKeyArray) &#123;</div><div class="line">            //从dic中获取映射多个key的值,返回映射到的第一个值</div><div class="line">        value = YYValueForMultiKeys(dictionary, propertyMeta-&gt;_mappedToKeyArray);</div><div class="line">    &#125; else if (propertyMeta-&gt;_mappedToKeyPath) &#123;</div><div class="line">            //从dic中获取映射keypath的值</div><div class="line">        value = YYValueForKeyPath(dictionary, propertyMeta-&gt;_mappedToKeyPath);</div><div class="line">    &#125; else &#123;</div><div class="line">            //从dic中获取映射key的值</div><div class="line">        value = [dictionary objectForKey:propertyMeta-&gt;_mappedToKey];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (value) &#123;</div><div class="line">            //Model 属性赋值</div><div class="line">        __unsafe_unretained id model = (__bridge id)(context-&gt;model);</div><div class="line">        ModelSetValueForProperty(model, value, propertyMeta);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最终实现model 属性赋值。 该方法比较长，首先对 meta的属性类型进行判断，主要分为三类，</p>
<ul>
<li>C基本数据类型</li>
<li>Foundation 类型</li>
<li>其他类型，如 id， Class ，block，SEL等等<br>根据类型获取对应value，</li>
</ul>
<p>最后都调用 <code>((void (*)(id, SEL, id))(void *) objc_msgSend)((id)model, meta-&gt;_setter, (id)value)</code> 进行model 属性赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">static void ModelSetValueForProperty(__unsafe_unretained id model,</div><div class="line">                                     __unsafe_unretained id value,</div><div class="line">                                     __unsafe_unretained _YYModelPropertyMeta *meta)</div></pre></td></tr></table></figure>
<h3 id="Model-转-JSON"><a href="#Model-转-JSON" class="headerlink" title="Model 转 JSON"></a>Model 转 JSON</h3><p>其中有效的JSON Object 只能是以下类型：<br>NSArray，NSDictionary，NSString，NSNumber，NSNull。</p>
<blockquote>
<p>1.如果是NSDictionary,NSSet,NSArray 类型，递归调用此方法获得JSON Object<br>2.如果是NSURL，NSAttributedString ，NSDate， NSData，做简单相应返回<br>3.根据Model类型创建modelMeta，取实例变量<code>_mapper</code> 获取所有属性名和｀<code>propertyMeta</code>,再根据<code>propertyMeta</code>的 类型<code>_type</code> 获得相应的 <code>value</code>, 根据有无<code>_mappedToKeyPath</code>再进一步处理，赋值，最后 判断有无自定义<code>_hasCustomTransformToDictionary</code>，返回最终转化结果</p>
</blockquote>
<p>主要方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div></pre></td><td class="code"><pre><div class="line">static id ModelToJSONObjectRecursive(NSObject *model) &#123;</div><div class="line">  </div><div class="line">    if (!model || model == (id)kCFNull) return model;</div><div class="line">    if ([model isKindOfClass:[NSString class]]) return model;</div><div class="line">    if ([model isKindOfClass:[NSNumber class]]) return model;</div><div class="line">    if ([model isKindOfClass:[NSDictionary class]]) &#123;</div><div class="line">        if ([NSJSONSerialization isValidJSONObject:model]) return model;</div><div class="line">        NSMutableDictionary *newDic = [NSMutableDictionary new];</div><div class="line">        [((NSDictionary *)model) enumerateKeysAndObjectsUsingBlock:^(NSString *key, id obj, BOOL *stop) &#123;</div><div class="line">            NSString *stringKey = [key isKindOfClass:[NSString class]] ? key : key.description;</div><div class="line">            if (!stringKey) return;</div><div class="line">            id jsonObj = ModelToJSONObjectRecursive(obj);</div><div class="line">            if (!jsonObj) jsonObj = (id)kCFNull;</div><div class="line">            newDic[stringKey] = jsonObj;</div><div class="line">        &#125;];</div><div class="line">        return newDic;</div><div class="line">    &#125;</div><div class="line">    if ([model isKindOfClass:[NSSet class]]) &#123;</div><div class="line">        NSArray *array = ((NSSet *)model).allObjects;</div><div class="line">        if ([NSJSONSerialization isValidJSONObject:array]) return array;</div><div class="line">        NSMutableArray *newArray = [NSMutableArray new];</div><div class="line">        for (id obj in array) &#123;</div><div class="line">            if ([obj isKindOfClass:[NSString class]] || [obj isKindOfClass:[NSNumber class]]) &#123;</div><div class="line">                [newArray addObject:obj];</div><div class="line">            &#125; else &#123;</div><div class="line">                id jsonObj = ModelToJSONObjectRecursive(obj);</div><div class="line">                if (jsonObj &amp;&amp; jsonObj != (id)kCFNull) [newArray addObject:jsonObj];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return newArray;</div><div class="line">    &#125;</div><div class="line">    if ([model isKindOfClass:[NSArray class]]) &#123;</div><div class="line">        if ([NSJSONSerialization isValidJSONObject:model]) return model;</div><div class="line">        NSMutableArray *newArray = [NSMutableArray new];</div><div class="line">        for (id obj in (NSArray *)model) &#123;</div><div class="line">            if ([obj isKindOfClass:[NSString class]] || [obj isKindOfClass:[NSNumber class]]) &#123;</div><div class="line">                [newArray addObject:obj];</div><div class="line">            &#125; else &#123;</div><div class="line">                id jsonObj = ModelToJSONObjectRecursive(obj);</div><div class="line">                if (jsonObj &amp;&amp; jsonObj != (id)kCFNull) [newArray addObject:jsonObj];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return newArray;</div><div class="line">    &#125;</div><div class="line">    if ([model isKindOfClass:[NSURL class]]) return ((NSURL *)model).absoluteString;</div><div class="line">    if ([model isKindOfClass:[NSAttributedString class]]) return ((NSAttributedString *)model).string;</div><div class="line">    if ([model isKindOfClass:[NSDate class]]) return [YYISODateFormatter() stringFromDate:(id)model];</div><div class="line">    if ([model isKindOfClass:[NSData class]]) return nil;</div><div class="line">    </div><div class="line">    _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:[model class]];</div><div class="line">    if (!modelMeta || modelMeta-&gt;_keyMappedCount == 0) return nil;</div><div class="line">    NSMutableDictionary *result = [[NSMutableDictionary alloc] initWithCapacity:64];</div><div class="line">    __unsafe_unretained NSMutableDictionary *dic = result; // avoid retain and release in block</div><div class="line">    [modelMeta-&gt;_mapper enumerateKeysAndObjectsUsingBlock:^(NSString *propertyMappedKey, _YYModelPropertyMeta *propertyMeta, BOOL *stop) &#123;</div><div class="line">        if (!propertyMeta-&gt;_getter) return;</div><div class="line">        </div><div class="line">        id value = nil;</div><div class="line">        if (propertyMeta-&gt;_isCNumber) &#123;</div><div class="line">            value = ModelCreateNumberFromProperty(model, propertyMeta);</div><div class="line">        &#125; else if (propertyMeta-&gt;_nsType) &#123;</div><div class="line">            id v = ((id (*)(id, SEL))(void *) objc_msgSend)((id)model, propertyMeta-&gt;_getter);</div><div class="line">            value = ModelToJSONObjectRecursive(v);</div><div class="line">        &#125; else &#123;</div><div class="line">            switch (propertyMeta-&gt;_type &amp; YYEncodingTypeMask) &#123;</div><div class="line">                case YYEncodingTypeObject: &#123;</div><div class="line">                    id v = ((id (*)(id, SEL))(void *) objc_msgSend)((id)model, propertyMeta-&gt;_getter);</div><div class="line">                    value = ModelToJSONObjectRecursive(v);</div><div class="line">                    if (value == (id)kCFNull) value = nil;</div><div class="line">                &#125; break;</div><div class="line">                case YYEncodingTypeClass: &#123;</div><div class="line">                    Class v = ((Class (*)(id, SEL))(void *) objc_msgSend)((id)model, propertyMeta-&gt;_getter);</div><div class="line">                    value = v ? NSStringFromClass(v) : nil;</div><div class="line">                &#125; break;</div><div class="line">                case YYEncodingTypeSEL: &#123;</div><div class="line">                    SEL v = ((SEL (*)(id, SEL))(void *) objc_msgSend)((id)model, propertyMeta-&gt;_getter);</div><div class="line">                    value = v ? NSStringFromSelector(v) : nil;</div><div class="line">                &#125; break;</div><div class="line">                default: break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (!value) return;</div><div class="line">        </div><div class="line">        if (propertyMeta-&gt;_mappedToKeyPath) &#123;</div><div class="line">            NSMutableDictionary *superDic = dic;</div><div class="line">            NSMutableDictionary *subDic = nil;</div><div class="line">            for (NSUInteger i = 0, max = propertyMeta-&gt;_mappedToKeyPath.count; i &lt; max; i++) &#123;</div><div class="line">                NSString *key = propertyMeta-&gt;_mappedToKeyPath[i];</div><div class="line">                if (i + 1 == max) &#123; // end</div><div class="line">                    if (!superDic[key]) superDic[key] = value;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                subDic = superDic[key];</div><div class="line">                if (subDic) &#123;</div><div class="line">                    if ([subDic isKindOfClass:[NSDictionary class]]) &#123;</div><div class="line">                        subDic = subDic.mutableCopy;</div><div class="line">                        superDic[key] = subDic;</div><div class="line">                    &#125; else &#123;</div><div class="line">                        break;</div><div class="line">                    &#125;</div><div class="line">                &#125; else &#123;</div><div class="line">                    subDic = [NSMutableDictionary new];</div><div class="line">                    superDic[key] = subDic;</div><div class="line">                &#125;</div><div class="line">                superDic = subDic;</div><div class="line">                subDic = nil;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            if (!dic[propertyMeta-&gt;_mappedToKey]) &#123;</div><div class="line">                dic[propertyMeta-&gt;_mappedToKey] = value;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    if (modelMeta-&gt;_hasCustomTransformToDictionary) &#123;</div><div class="line">        BOOL suc = [((id&lt;YYModel&gt;)model) modelCustomTransformToDictionary:dic];</div><div class="line">        if (!suc) return nil;</div><div class="line">    &#125;</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.jianshu.com/users/aa41dad549af/latest_articles" target="_blank" rel="external">郑钦洪_：YYModel 源码历险记</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hexo + Github-Pages 从零开始搭建个人博客]]></title>
      <url>http://ChenAo0727.github.io/2016/12/28/hexo/</url>
      <content type="html"><![CDATA[<p>   <strong>经过各种找资料，踩过各种坑，终于搭建好了个人博客，安装hexo是3.2.2版本，hexo不同的版本，配置稍微有些不一样。由于本人使用的是Mac，下面的都是针对Mac的，Windows下的配置类似。</strong></p>
<hr>
<h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p><a href="https://github.com/hexjs/hexo" target="_blank" rel="external">hexo</a>是一个基于Node.js的简单，快速，强大的静态博客框架,可以方便的生成静态网页托管在github上，作者是来自台湾的 Tommy Chen。特点：</p>
<ul>
<li>不可思议的快速 ─ 只要一眨眼静态文件即生成完成</li>
<li>支持 Markdown</li>
<li>仅需一道指令即可部署到 GitHub Pages 和 Heroku</li>
<li>已移植 Octopress 插件</li>
<li>高扩展性、自订性</li>
<li>兼容于 Windows, Mac &amp; Linux<a id="more"></a>
<h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3></li>
</ul>
<blockquote>
<p>1.安装Node.js ,用来生成静态页面的。到<a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js官网</a>下载相应平台的最新版本，一路安装即可。npm是随同Node.js一起安装的包管理工具，能解决Node.js代码部署上的很多问题</p>
<p>2.安装Git，把本地的hexo内容提交到github上去，需要和Hexo建立连接，下面会有说到</p>
<p>3.申请GitHub,是用来做博客的远程创库、域名、服务器之类的,github账号没有的话直接申请就行了，跟一般的注册账号差不多，SSH Keys，看你自己了，可以不配制，不配置的话以后每次对自己的博客有改动提交的时候就要手动输入账号密码，配置了就不需要了，怎么配置我就不多说了，网上有很多教程</p>
</blockquote>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>Node和Git都安装好后，即可开始安装Hexo 具体可以查看<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">Hexo中文文档</a></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install -g hexo</div></pre></td></tr></table></figure>
<p>这里可能安装失败，可能权限不够，在命令前加 <code>sudo</code>。<br>安装成功以后,就可以创建blog。首先创建一个文件夹,如MyBlog,这是你的博客根目录，用于存放hexo的配置文件,然后进入MyBlog里初始化Hexo。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo init</div></pre></td></tr></table></figure>
<p> 需要等待一段时间，成功后会显示：<code>INFO  Start blogging with Hexo!</code> 这时的MyBlog 目录下有以下这些文件</p>
<pre><code>.
├── _config.yml
├── node_modules
├── package.json
├── source
├── scripts
├── scaffolds
|   ├── drafts
|   ├── posts
|   └── page
└── themes
</code></pre><ul>
<li>_config.yml：全局配置文件，大多数的设置都在这里 <strong>配置项都需要空一格</strong></li>
<li>node_modules: node的一些模块组件</li>
<li>package.json：应用程序数据，指明hexo的版本等信息，类似于一般软件中的关于按钮</li>
<li>scaffolds：layout模板文件目录，其中的md文件可以添加编辑 drafts：草稿文章 posts：发布文章</li>
<li>scripts：扩展脚本目录，这里可以自定义一些javascript脚本</li>
<li>source：文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里，该目录下可新建页面目录</li>
<li>themes：主题文件目录</li>
</ul>
<p><strong>_config.yml</strong> 用到的比较多</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"># Hexo Configuration</div><div class="line"> ## Docs: https://hexo.io/docs/configuration.html</div><div class="line"> ## Source: https://github.com/hexojs/hexo/</div><div class="line"></div><div class="line"> # Site 站点信息:定义标题,作者,语言</div><div class="line"> title: 这里是你博客的标题</div><div class="line"> subtitle: 子标题</div><div class="line"> description: 个人介绍</div><div class="line"> author: 笔名</div><div class="line"> language: zh_CN </div><div class="line"> timezone: Asia/Shanghai</div><div class="line"></div><div class="line"> # URL Url访问路径</div><div class="line"> ## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</div><div class="line"> url: http://yoursite.com</div><div class="line"> root: /</div><div class="line"> permalink: :year/:month/:day/:title/</div><div class="line"> permalink_defaults:</div><div class="line"></div><div class="line"> # Directory 文件目录:正文的存储目录</div><div class="line"> source_dir: source</div><div class="line"> public_dir: public</div><div class="line"> tag_dir: tags</div><div class="line"> archive_dir: archives</div><div class="line"> category_dir: categories</div><div class="line"> code_dir: downloads/code</div><div class="line"> i18n_dir: :lang</div><div class="line"> skip_render:</div><div class="line"></div><div class="line"> # Writing 写博客配置:文章标题,文章类型,外部链接</div><div class="line"> new_post_name: :title.md # File name of new posts</div><div class="line"> default_layout: post</div><div class="line"> titlecase: false # Transform title into titlecase</div><div class="line"> external_link: true # Open external links in new tab</div><div class="line"> filename_case: 0</div><div class="line"> render_drafts: false</div><div class="line"> post_asset_folder: false</div><div class="line"> relative_link: false</div><div class="line"> future: true</div><div class="line"> highlight:</div><div class="line"> enable: true</div><div class="line"> line_number: true</div><div class="line"> auto_detect: false</div><div class="line"> tab_replace:</div><div class="line"></div><div class="line"> # Category &amp; Tag   目录和标签:默认分类,分类图,标签图</div><div class="line"> default_category: uncategorized</div><div class="line"> category_map:</div><div class="line"> tag_map:</div><div class="line"></div><div class="line"> # Date / Time format 时间和日期格式:</div><div class="line"> ## Hexo uses Moment.js to parse and display date</div><div class="line"> ## You can customize the date format as defined in</div><div class="line"> ## http://momentjs.com/docs/#/displaying/format/</div><div class="line"> date_format: YYYY-MM-DD</div><div class="line"> time_format: HH:mm:ss</div><div class="line"></div><div class="line"> # Pagination   分页设置:每页显示数量</div><div class="line"> ## Set per_page to 0 to disable pagination</div><div class="line"> per_page: 10</div><div class="line"> pagination_dir: page</div><div class="line"></div><div class="line"> # Extensions   插件和皮肤:换皮肤,安装插件</div><div class="line"> ## Plugins: https://hexo.io/plugins/</div><div class="line"> ## Themes: https://hexo.io/themes/</div><div class="line"> theme: landscape 默认主题</div><div class="line"></div><div class="line"> # Deployment   部署配置:github发布,type类型为git</div><div class="line"> ## Docs: https://hexo.io/docs/deployment.html</div><div class="line"> deploy:</div><div class="line"> type:</div></pre></td></tr></table></figure>
<p>接下来就是配置_config.yml，以及一些 Hexo 指令操作</p>
<h3 id="Hexo常用命令"><a href="#Hexo常用命令" class="headerlink" title="Hexo常用命令"></a>Hexo常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">hexo new postName       #新建文章 在source/_posts 下生成</div><div class="line">hexo new page pageName  #新建页面 在source/pageName 下生成</div><div class="line">hexo deploy             #将.deploy目录部署到GitHub 简写指令：hexo d </div><div class="line">hexo generate           #生成静态页面至public目录 简写指令：hexo g </div><div class="line">hexo server             #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）简写指令hexo s </div><div class="line">hexo clean              #清除所有静态页面和缓存数据</div></pre></td></tr></table></figure>
<p>默认在source/_posts 存在了hello-world.md 可以直接输入 <code>hexo generate</code> 生成静态网页<br>这时目录下多了 <code>public</code> 这是生成静态网页内容目录。可以输入 <code>hexo clean</code> 清除</p>
<p>生成静态网页后，就能启动本地服务，可以进行文章预览调试，输入 <code>hexo server</code> 默认是4000端口，在服务器启动期间，Hexo 会监视文件变动并自动更新，您无须重启服务器。如果是第二次会提示，<code>Port 4000 has been used. Try other port instead</code> 这时可以输入指定的端口 <code>hexo server －p xxxx</code> 如 7681 输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">INFO  Start processing</div><div class="line">INFO  Hexo is running at http://localhost:7681/. Press Ctrl+C to stop.</div></pre></td></tr></table></figure>
<p>浏览器输入<a href="http://localhost:7681" target="_blank" rel="external">http://localhost:7681</a> 就可以预览页面</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1618300-fbd39a297c267d2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2016-12-28 下午1.53.15.png"></p>
<p>这是正常的情况，可能中间会有一些错误提示</p>
<h3 id="Hexo-Server-错误"><a href="#Hexo-Server-错误" class="headerlink" title="Hexo Server 错误"></a>Hexo Server 错误</h3><p>Hexo 3.0 把服务器独立成了个别模块，您必须先安装 <a href="https://github.com/hexojs/hexo-server" target="_blank" rel="external">hexo-server</a>才能使用，需要执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-server --save</div></pre></td></tr></table></figure>
<h3 id="页面显示白板和Cannot-GET"><a href="#页面显示白板和Cannot-GET" class="headerlink" title="页面显示白板和Cannot GET"></a>页面显示白板和Cannot GET</h3><p>原因：</p>
<p>由于2.6以后就更新了，我们需要手动配置些东西，我们需要输入下面三行命令，看情况添加 <code>sudo</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-renderer-ejs --save</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-renderer-stylus --save</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-renderer-marked --save</div></pre></td></tr></table></figure>
<h3 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h3><p>在github建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】。然后建立关联</p>
<p>安装 <a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="external">hexo-deployer-git</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure>
<p>在 <code>_config.yml</code> 配置文件中修改参数,在文件最下面，一个正确的部署配置中至少要有 type 参数，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">type: git</div><div class="line">repo: &lt;repository url&gt; 库（Repository）地址</div><div class="line">branch: [branch] 分支名称。如果您使用的是 GitHub 或 GitCafe 的话，程序会尝试自动检测。</div><div class="line">message: [message] 自定义提交信息 (默认为 Site updated: &#123;&#123; now(&apos;YYYY-MM-DD HH:mm:ss&apos;) &#125;&#125;)</div></pre></td></tr></table></figure>
<p>Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo deploy</div></pre></td></tr></table></figure>
<p>执行这条命令后会生成一个隐藏文件夹<code>.deploy_git</code> ,可以输入<code>ls -a</code> 打开查看，hexo会将生成的public文件夹复制到.deploy_git文件夹中</p>
<h3 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h3><p><code>sources/_posts</code> 目录下打开默认的<code>Hello－Word.md</code>,文章一般头部格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">title: xxxx                    #文章的标题，这个才是显示的文章标题，其实文件名不影响</div><div class="line">date: 2015-09-01 20:33:26      #用命令会自动生成，也可以自己写，所以文章时间可以改</div><div class="line">categories: xxx                #自定义文章的分类</div><div class="line">tags: xxx                      #tag，为文章添加标签，方便搜索</div><div class="line"> ---</div></pre></td></tr></table></figure>
<p><strong>注意点</strong></p>
<ul>
<li>如果在博客文章列表中，不想全文显示，可以增加 <code>&lt;!--more--&gt;</code>, 后面的内容就不会显示在列表。</li>
<li>Markdown标题标准写法写法需要在”#”和后面字符之间加一个空格，如果不加空格 有些引擎就解析不了</li>
</ul>
<h3 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h3><ul>
<li>Windows下可以使用 MarkdownPad2</li>
<li>Mac 建议使用 Mou 这款免费且十分好用的 Markdown 编辑器</li>
<li>Web 端上，推荐简书这款产品<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3>可以在<code>package.json</code>中查看已经安装的插件</li>
</ul>
<p><strong>添加RSS</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-generator-feed --save</div></pre></td></tr></table></figure>
<p>然后，到博客目录 /public 下，会有atom.xml生成 再到_config.yml 里配置一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">feed:</div><div class="line">     type: atom      #type 表示类型, 是 atom 还是 rss2.</div><div class="line">     path: atom.xml  #path 表示 Feed 路径</div><div class="line">     limit: 20       #limit 最多多少篇最近文章</div></pre></td></tr></table></figure>
<p><strong>添加Sitemap</strong></p>
<blockquote>
<p>Sitemap 的提交主要的目的，是要避免搜索引擎的爬虫没有完整的收录整个网页的内容，所以提交 Sitemap 是能够补足搜索引擎的不足，进而加速网页的收录速度，达到搜寻引擎友好的目的。</p>
</blockquote>
<p><a href="https://www.npmjs.com/package/hexo-generator-sitemap" target="_blank" rel="external">hexo-generator-sitemap</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-generator-sitemap --save</div></pre></td></tr></table></figure>
<p>同样在_config.yml 里配置一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sitemap:</div><div class="line">    path: sitemap.xml</div><div class="line">    #path 表示 Sitemap 的路径. 默认为 sitemap.xml.</div></pre></td></tr></table></figure>
<p>对于国内用户还需要安装插件 hexo-generator-baidu-sitemap, 顾名思义是为百度量身打造的. 安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-generator-baidu-sitemap --save</div></pre></td></tr></table></figure>
<p>然后在_config.yml里配置一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">baidusitemap:</div><div class="line">    path: baidusitemap.xml</div></pre></td></tr></table></figure>
<p><strong>添加搜索</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-generator-search</div></pre></td></tr></table></figure>
<p><strong>其他插件</strong></p>
<p><a href="https://github.com/hexojs/hexo/wiki/Plugins" target="_blank" rel="external">Plugins·hexojs/hexo</a></p>
<h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><p>默认的是landscape，这里有大量的<a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="external">主题列表</a></p>
<p>安装喜欢的主题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git clone &lt;repository&gt; themes/themeName</div></pre></td></tr></table></figure>
<p>需要在_config.yml 中更改theme: themeName 更改主题后需要重新 <code>hexo g</code> 生成页面<br>在主题的_config.yml文件里面可以修改头像，友情链接等等，配置需要展示的页面元素，一般里面都会有介绍</p>
<h3 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h3><p>在Hexo中，默认使用的评论是国外的Disqus,不过因为国内的”网络环境”问题，我们改为国内的多说评论系统。<br>需要设置 short_name:字段，这个字段为你多说填写的站点名字，比如我的域名：chenao0727github.duoshuo.com，那么我的short_name: chenao0727github</p>
<h3 id="404页面"><a href="#404页面" class="headerlink" title="404页面"></a>404页面</h3><blockquote>
<p>GitHub Pages 自定义404页面非常容易，直接在根目录下创建自己的404.html就可以。但是自定义404页面仅对绑定顶级域名的项目才起作用，GitHub默认分配的二级域名是不起作用的，使用hexo server在本机调试也是不起作用的。</p>
</blockquote>
<h3 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h3><blockquote>
<p>因Google Analytics偶尔被墙，故国内用百度统计</p>
</blockquote>
<p>最新的统计服务已经开放，两行代码轻松搞定，你可以直接使用：<a href="http://service.ibruce.info" target="_blank" rel="external">不蒜子</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Swift 闭包]]></title>
      <url>http://ChenAo0727.github.io/2016/12/27/Swift-closure/</url>
      <content type="html"><![CDATA[<p>Swift 中的闭包是自包含的函数代码块，可以在代码中被传递和使用。类似于OC中的Block以及其他函数的匿名函数。闭包可以捕获和存储其所在上下文中任意常量和变量的引用，被称为包裹常量和变量。Swift可以为你管理在捕获过程中涉及到的所有内存操作 <a id="more"></a></p>
<h3 id="函数与闭包的关系"><a href="#函数与闭包的关系" class="headerlink" title="函数与闭包的关系"></a>函数与闭包的关系</h3><p>全局和嵌套函数实际上也是特殊的閉包，闭包有如下三种形式：<br>1.全局函数是一個有名字但不会捕获任何值的闭包<br>2.嵌套函数是一個有名字並可以捕获其封闭函数域内值的闭包<br>3.闭包表达式是一個利用轻量级语法所写的可以捕获其上下文中变量或常量值的匿名闭包</p>
<ul>
<li>闭包表达式</li>
<li>尾随闭包</li>
<li>值捕获</li>
<li>闭包是引用类型</li>
<li>逃逸闭包</li>
<li>自动闭包</li>
</ul>
<h3 id="闭包表达式一般形式"><a href="#闭包表达式一般形式" class="headerlink" title="闭包表达式一般形式:"></a>闭包表达式一般形式:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123; (parameters) -&gt; returnType in</div><div class="line">    statements</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面以 <code>Swift</code> 标准库中的 <code>sorted(by:)</code> 方法为例，展示闭包的各种书写格式。它会根据闭包函数中的实现将数组中的值进行排序，返回一个与原数组大小相同，包含相同元素且重新排序的新数组。原数组不会被 <code>sorted(by:)</code> 方法修改 </p>
<h3 id="最复杂的形式"><a href="#最复杂的形式" class="headerlink" title="最复杂的形式"></a>最复杂的形式</h3><p>原数组： <code>let names = [&quot;Linda&quot;, &quot;Cindy&quot;, &quot;Benty&quot;, &quot;Dandy&quot;]</code><br>排序后数组：<code>sortNames = names.sorted(by: { (s1: String, s2: String) -&gt; Bool in return s1 &lt; s2 } )   print(sortNames) // [ &quot;Benty&quot;, &quot;Cindy&quot;, &quot;Dandy&quot;,&quot;Linda&quot;]</code><br>如果第一个字符串s1小于 第二个字符串s2， 函数会返回 true，在新的数组中 s1 应该出现在 s2 前。对于字符串中的字符来说，“小于”表示“按照字母顺序较晚出现”。这意味着字母 “A” 小于字母 “B” ，字符串 “Ab” 小于字符串 “Ac”。该闭包将进行字母顺序排序，”Benty” 将会排在 “Cindy” 之前。</p>
<h3 id="上下文推断类型"><a href="#上下文推断类型" class="headerlink" title="上下文推断类型"></a>上下文推断类型</h3><p>排序闭包函数作为 <code>sorted(by:)</code> 方法的参数传入，Swift 可以推断其参数和返回值的类型。<code>sorted(by:)</code> 方法被一个字符串数组调用，因此其参数必须是 <code>(String, String) -&gt; Bool</code> 类型。这意味着 (String, String) 和 Bool 类型并不需要作为闭包表达式定义的一部分。因为所有的类型都可以被正确推断，返回箭头（-&gt;）和围绕在参数周围的括号也可以被省略：<br><code>sortNames = names.sorted(by: { s1, s2 in return s1 &lt; s2 } )</code><br>尽管如此，你仍然可以明确写出有着完整格式的闭包。如果完整格式的闭包能够提高代码的可读性，则我们更鼓励采用完整格式的闭包。而在 <code>sorted(by:)</code> 方法这个例子里，显然闭包的目的就是排序。由于这个闭包是为了处理字符串数组的排序，因此读者能够推测出这个闭包是用于字符串处理的。</p>
<h3 id="单表达式闭包隐式返回"><a href="#单表达式闭包隐式返回" class="headerlink" title="单表达式闭包隐式返回"></a>单表达式闭包隐式返回</h3><p><code>sortNames = names.sorted(by: { s1, s2 in s1 &lt; s2 } )</code><br>在这个例子中，<code>sorted(by:)</code> 方法的参数类型明确了闭包必须返回一个 Bool 类型值。因为闭包函数体只包含了一个单一表达式（s1 &lt; s2），该表达式返回 Bool 类型值，因此这里没有歧义，return 关键字可以省略</p>
<h3 id="参数名称缩写"><a href="#参数名称缩写" class="headerlink" title="参数名称缩写"></a>参数名称缩写</h3><p>Swift 自动为内联闭包提供了参数名称缩写功能，你可以直接通过 $0，$1，$2 来顺序调用闭包的参数，以此类推。如果你在闭包表达式中使用参数名称缩写，你可以在闭包定义中省略参数列表，并且对应参数名称缩写的类型会通过函数类型进行推断。in关键字也同样可以被省略，因为此时闭包表达式完全由闭包函数体构成：<br><code>sortNames = names.sorted(by: { $0 &lt; $1 } )</code><br>在这个例子中，$0和$1表示闭包中第一个和第二个 String 类型的参数。</p>
<h3 id="运算符方法"><a href="#运算符方法" class="headerlink" title="运算符方法"></a>运算符方法</h3><p>实际上还有一种更简短的方式来编写上面例子中的闭包表达式。Swift 的 String 类型定义了关于小于号（&lt;）的字符串实现，其作为一个函数接受两个 String 类型的参数并返回 Bool 类型的值。而这正好与 sorted(by:) 方法的参数需要的函数类型相符合。因此，你可以简单地传递一个小于号，Swift 可以自动推断出你想使用小于号的字符串函数实现：<br><code>sortNames = names.sorted(by: &lt;)</code></p>
<h3 id="尾随闭包"><a href="#尾随闭包" class="headerlink" title="尾随闭包"></a>尾随闭包</h3><p>如果你需要将一个很长的闭包表达式作为最后一个参数传递给函数，可以使用尾随闭包来增强函数的可读性。尾随闭包是一个书写在函数括号之后的闭包表达式，函数支持将其作为最后一个参数调用。在使用尾随闭包时，你不用写出它的参数标签。<br> <code>sortNames = names.sorted() { $0 &lt; $1 }</code><br>如果闭包表达式是函数或方法的唯一参数，则当你使用尾随闭包时，你甚至可以把 () 省略掉：<code>sortNames =names.sorted { $0 &lt; $1 }</code></p>
<h3 id="值捕获"><a href="#值捕获" class="headerlink" title="值捕获"></a>值捕获</h3><p>闭包可以在其被定义的上下文中捕获常量或变量。即使定义这些常量和变量的原作用域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。<br>举个例子，这有一个叫做 <code>makeIncrementor</code> 的函数，其包含了一个叫做 <code>incrementor</code> 的嵌套函数。嵌套函数 <code>incrementor()</code> 从上下文中捕获了两个值，<code>runningTotal</code> 和 <code>amount</code>。捕获这些值之后，<code>makeIncrementor</code> 将 <code>incrementor</code> 作为闭包返回。每次调用 <code>incrementor</code> 时，其会以 <code>amount</code> 作为增量增加 <code>runningTotal</code> 的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">func makeIncrementer(forIncrement amount: Int) -&gt; () -&gt; Int &#123;</div><div class="line">    var runningTotal = 0</div><div class="line">    func incrementer() -&gt; Int &#123;</div><div class="line">        runningTotal += amount</div><div class="line">        return runningTotal</div><div class="line">    &#125;</div><div class="line">    return incremented</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>makeIncrementor</code> 返回类型为 <code>() -&gt; Int</code>。这意味着其返回的是一个<em>函数</em>，而非一个简单类型的值。该函数在每次调用时不接受参数，只返回一个 <code>Int</code> 类型的值 <code>makeIncrementer(forIncrement:)</code> 函数定义了一个初始值为 <code>0</code> 的整型变量 <code>runningTotal</code>，用来存储当前总计数值。该值为 <code>incrementor</code> 的返回值<br><code>makeIncrementer(forIncrement:)</code> 有一个 <code>Int</code> 类型的参数，其外部参数名为 <code>forIncrement</code>，内部参数名为 <code>amount</code>，该参数表示每次<br> <code>incrementor</code> 被调用时 <code>runningTotal</code> 将要增加的量。<code>makeIncrementer</code> 函数还定义了一个嵌套函数 <code>incrementor</code>，用来执行实际的增加操作。该函数简单地使 <code>runningTotal</code> 增加 <code>amount</code>，并将其返回。<br>如果我们单独考虑嵌套函数 <code>incrementer()</code>，会发现它有些不同寻常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">func incrementer() -&gt; Int &#123;</div><div class="line">    runningTotal += amount</div><div class="line">    return runningTotal</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>incrementer()</code> 函数并没有任何参数，但是在函数体内访问了 <code>runningTotal</code> 和 <code>amount</code> 变量。这是因为它从外围函数捕获了<br><code>runningTotal</code> 和 <code>amount</code> 变量的<em>引用</em>。捕获引用保证了 <code>runningTotal</code> 和 <code>amount</code> 变量在调用完 <code>makeIncrementer</code> 后不会消失，并且保证了在下一次执行 <code>incrementer</code> 函数时，<code>runningTotal</code> 依旧存在。</p>
<h3 id="闭包是引用类型"><a href="#闭包是引用类型" class="headerlink" title="闭包是引用类型"></a>闭包是引用类型</h3><p>上面的例子中，incrementBySeven 和 incrementByTen 都是常量，但是这些常量指向的闭包仍然可以增加其捕获的变量的值。这是因为函数和闭包都是引用类型。无论你将函数或闭包赋值给一个常量还是变量，你实际上都是将常量或变量的值设置为对应函数或闭包的引用。上面的例子中，指向闭包的引用 incrementByTen 是一个常量，而并非闭包内容本身。这也意味着如果你将闭包赋值给了两个不同的常量或变量，两个值都会指向同一个闭包：<br><code>let alsoIncrementByTen = incrementByTen alsoIncrementByTen() // 返回的值为50</code></p>
<h3 id="逃逸闭包"><a href="#逃逸闭包" class="headerlink" title="逃逸闭包"></a>逃逸闭包</h3><p>当一个闭包作为参数传到一个函数中，但是这个闭包在函数返回之后才被执行，我们称该闭包从函数中逃逸。当你定义接受闭包作为参数的函数时，你可以在参数名之前标注 <code>@escaping</code>，用来指明这个闭包是允许“逃逸”出这个函数的。一种能使闭包“逃逸”出函数的方法是，将这个闭包保存在一个函数外部定义的变量中。举个例子，很多启动异步操作的函数接受一个闭包参数作为 <code>completion handler</code>。这类函数会在异步操作开始之后立刻返回，但是闭包直到异步操作结束后才会被调用。在这种情况下，闭包需要“逃逸”出函数，因为闭包需要在函数返回之后被调用。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var completionHandlers: [() -&gt; Void] = [] </div><div class="line">//逃逸闭包</div><div class="line">func someFunctionWithEscapingClosure(completionHandler: @escaping () -&gt; Void) &#123;</div><div class="line">     completionHandlers.append(completionHandler)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> <code>someFunctionWithEscapingClosure(_:)</code> 函数接受一个闭包作为参数，该闭包被添加到一个函数外定义的数组中。如果你不将这个参数标记为 <code>@escaping</code> 就会得到一个编译错误。将一个闭包标记为 <code>@escaping</code> 意味着你必须在闭包中显式地引用 <code>self</code> 。比如说，在下面的代码中，传递到 <code>someFunctionWithEscapingClosure(_:)</code> 中的闭包是一个逃逸闭包，这意味着它需要显式地引用 <code>self</code>。相对的，<br> 传递到 <code>someFunctionWithNonescapingClosure(_:)</code> 中的闭包是一个非逃逸闭包，这意味着它可以隐式引用 <code>self</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">func someFunctionWithNonescapingClosure(closure: () -&gt; Void) &#123; </div><div class="line">    closure() </div><div class="line">&#125; </div><div class="line">        var x = 10</div><div class="line">        func doSomething() &#123; </div><div class="line">        someFunctionWithEscapingClosure &#123; </div><div class="line">           //逃逸闭包 需要显式地引用 self</div><div class="line">          //调用doSomething 不会执行闭包</div><div class="line">            self.x = 100 </div><div class="line">       &#125; </div><div class="line">       someFunctionWithNonescapingClosure &#123; </div><div class="line">          //因为不是逃逸闭包，调用doSomething 执行闭包</div><div class="line">           x = 200</div><div class="line">      &#125; </div><div class="line">   &#125; </div><div class="line"></div><div class="line">      doSomething() </div><div class="line">      print(x) // 打印出 &quot;200&quot; </div><div class="line">      completionHandlers.first?()</div><div class="line">      print(x)  // 打印出 &quot;100&quot;  逃逸闭包调用</div></pre></td></tr></table></figure>
<h3 id="自动闭包"><a href="#自动闭包" class="headerlink" title="自动闭包"></a>自动闭包</h3><p>自动闭包是一种自动创建的闭包，用于包装传递给函数作为参数的表达式。这种闭包不接受任何参数，当它被调用的时候，会返回被包装在其中的表达式的值。这种便利语法让你能够省略闭包的花括号，用一个普通的表达式来代替显式的闭包。<br>我们经常会调用采用自动闭包的函数，但是很少去实现这样的函数。举个例子来说，<code>assert(condition:message:file:line:)</code> 函数接受自动闭包作为它的 <code>condition</code> 参数和 <code>message</code>参数；它的 <code>condition</code> 参数仅会在 <code>debug</code> 模式下被求值，它的 message 参数仅当<br> <code>condition</code> 参数为 <code>false</code> 时被计算求值。<br>自动闭包让你能够延迟求值，因为直到你调用这个闭包，代码段才会被执行。延迟求值对于那些有副作用（Side Effect）和高计算成本的代码来说是很有益处的，因为它使得你能控制代码的执行时机。下面的代码展示了闭包如何延时求值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var customersInLine = [&quot;Chris&quot;, &quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]</div><div class="line">print(customersInLine.count)</div><div class="line">// 打印出 &quot;5&quot;</div><div class="line">let customerProvider = &#123; customersInLine.remove(at: 0) &#125;</div><div class="line">print(customersInLine.count)</div><div class="line">// 打印出 &quot;5&quot;</div><div class="line">print(&quot;Now serving \(customerProvider())!&quot;)</div><div class="line">// Prints &quot;Now serving Chris!&quot;</div><div class="line">print(customersInLine.count)</div><div class="line">// 打印出 &quot;4&quot;</div></pre></td></tr></table></figure>
<p>尽管在闭包的代码中，<code>customersInLine</code> 的第一个元素被移除了，不过在闭包被调用之前，这个元素是不会被移除的。如果这个闭包永远不被调用，那么在闭包里面的表达式将永远不会执行，那意味着列表中的元素永远不会被移除。请注意，<code>customerProvider</code> 的类型不是<br><code>String</code> ，而是<code>() -&gt; String</code> ，一个没有参数且返回值为 <code>String</code> 的函数。将闭包作为参数传递给函数时，你能获得同样的延时求值行为。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">   let customersInLine = [&quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;] </div><div class="line">    func serve(customer customerProvider: () -&gt; String) &#123;</div><div class="line">    print(&quot;Now serving \(customerProvider())!&quot;) </div><div class="line">&#125; </div><div class="line"> serve(customer: &#123; customersInLine.remove(at: 0) &#125; )</div><div class="line"> // 打印出 &quot;Now serving Alex!&quot;</div></pre></td></tr></table></figure>
<p>上面的 <code>serve(customer:)</code> 函数接受一个返回顾客名字的显式的闭包。下面这个版本的 <code>serve(customer:)</code> 完成了相同的操作，不过它并没有接受一个显式的闭包，而是通过将参数标记为 <code>@autoclosure</code> 来接收一个自动闭包。现在你可以将该函数当作接受 <code>String</code> 类型参数<br>（而非闭包）的函数来调用。<code>customerProvider</code> 参数将自动转化为一个闭包，因为该参数被标记了<code>@autoclosure</code> 特性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">    let customersInLine = [&quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]</div><div class="line">    func serve(customer customerProvider: @autoclosure () -&gt; String) &#123; </div><div class="line">    print(&quot;Now serving \(customerProvider())!&quot;)</div><div class="line"> &#125; </div><div class="line">serve(customer: customersInLine.remove(at: 0)) </div><div class="line">// 打印 &quot;Now serving Ewa!&quot;</div></pre></td></tr></table></figure>
<p>注意 过度使用 <code>autoclosures</code> 会让你的代码变得难以理解。上下文和函数名应该能够清晰地表明求值是被延迟执行的。</p>
<p>如果你想让一个自动闭包可以“逃逸”，则应该同时使用 <code>@autoclosure</code> 和 <code>@escaping</code> 属性。<code>@escaping</code> 属性的讲解见上面的逃逸闭包。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">customersInLine i= [&quot;Barry&quot;, &quot;Daniella&quot;] </div><div class="line">var customerProviders: [() -&gt; String] = []</div><div class="line"> func collectCustomerProviders(_ customerProvider: @autoclosure @escaping () -&gt; String) &#123; </div><div class="line">customerProviders.append(customerProvider) </div><div class="line">&#125;</div><div class="line"> collectCustomerProviders(customersInLine.remove(at: 0)) </div><div class="line"> collectCustomerProviders(customersInLine.remove(at: 0))</div><div class="line"> print(&quot;Collected (customerProviders.count) closures.&quot;) </div><div class="line">// 打印 &quot;Collected 2 closures.&quot;</div><div class="line"> for customerProvider in customerProviders &#123;</div><div class="line"> print(&quot;Now serving (customerProvider())!&quot;) </div><div class="line">&#125; // 打印 &quot;Now serving Barry!&quot; // 打印 &quot;Now serving Daniella!&quot;</div></pre></td></tr></table></figure>
<p>在上面的代码中，<code>collectCustomerProviders(_:)</code> 函数并没有调用传入的 <code>customerProvider</code> 闭包<br>而是将闭包追加到了 <code>customerProviders</code> 数组中。这个数组定义在函数作用域范围外，这意味着数组内的闭包能够在函数返回之后被调用。因此，<code>customerProvider</code> 参数必须允许“逃逸”出函数作用域。</p>
<h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>本文内容摘自中文版 Apple 官方 Swift 教程，对于初学swift的朋友有较大帮助，下面是苹果官方文档链接和github中文文档链接 <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html#//apple_ref/doc/uid/TP40014097-CH11-ID94" target="_blank" rel="external">官方文档</a> <a href="https://github.com/numbbbbb/the-swift-programming-language-in-chinese" target="_blank" rel="external">中文文档</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Kingfisher 3.x 学习（一）]]></title>
      <url>http://ChenAo0727.github.io/2016/12/26/Kingfisher/</url>
      <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p><code>Kingfisher</code>  是喵神的一个异步下载和缓存图片的Swift库，类似于OC 的<code>SDWebImage</code>  <a href="http://project.onevcat.com" target="_blank" rel="external">中文简介</a>，<a href="https://github.com/onevcat/Kingfisher" target="_blank" rel="external">github地址</a>  我现在使用的3.版本不是很了解，直接以最新版本来学习了 由于个人水平有限 如有错误还望包涵  <a id="more"></a></p>
<h2 id="Kingfisher的架构"><a href="#Kingfisher的架构" class="headerlink" title="Kingfisher的架构"></a>Kingfisher的架构</h2><p>阅读他人优秀代码是一个提高自身代码水平很好的方法。花了几天的时间，看了<code>Kingfisher</code> 的源代码，里面包含的很多知识点，让我受益匪浅。3.x版本相比与之前的版本，一个重要的改变就是<code>protocol</code> 的灵活运用，更加面向协议编程。当然还有其他很多知识，比如多线程，枚举，闭包，Extension 等等应用。 <code>Kingfisher中</code> 有<code>Core</code>，<code>Extension</code>，<code>Helpers</code> 三个目录结构 共20个文件</p>
<p>Core<br><code>image.swift</code> 文件内部对 UIImage 以及 NSData 进行了拓展, 包含判定图片类型、图片解码以及Gif数据处理等操作<br><code>Indicator.swift</code> 图片加载时loading指示<br><code>ImageCache.swift</code> 主要负责将加载过的图片缓存至本地。<br><code>ImageDownloader.swift</code> 负责下载网络图片。<br><code>ImagePrefetcher.swift</code> 可用于提前指定一些图片下载<br><code>ImageProcessor.swift</code> 可用于将下载的数据合成图片对象<br><code>CacheSerializer.swift</code> 可用于图像对象序列化成图像数据存储到磁盘缓存和从磁盘缓存将图片数据反序列化成图像对象。<br><code>RequestModifier.swift</code> 下载图像请求修改器。<br><code>ImageTransition.swift</code> 过渡动画效果 使用<code>UIViewAnimationOptions</code>动画效果<br><code>KingfisherManager.swift</code>  Kingfisher 管理控制类，拥有图片下载及缓存功能<br><code>KingfisherOptionsInfo.swift</code> 枚举KingfisherOptionsInfoItem 配置 Kingfisher 行为的参数，包括 是否自定义缓存对象  是否自定义下载器  是否过渡动画  是否设置下载低优先级 是否强制刷新 是否仅获取缓存图片 是否仅缓存至内存、是否允许图像后台解码等设置。<br><code>Filter.swift</code> 图像过滤器<br><code>Resource.swift</code>  记录了图片的下载地址和缓存Key。<br><code>Kingfisher.swift</code> 添加KingfisherCompatible通用协议 kf新属性</p>
<p>Extension<br><code>ImageView+Kingfisher.swift</code> <code>UIButton+Kingfisher.swift</code>  <code>NSButton+Kingfisher</code> 对 <code>UIImageView</code>  <code>UIButton</code> <code>NSButton</code> 进行了拓展 主要用于提供 Kingfisher 的外部接口。</p>
<p>Helpers<br><code>String+MD5.swift</code> 负责图片缓存时对文件名进行MD5加密操作。<br><code>Box.swift</code> 一个简单泛型类<br><code>ThreadHelper.swift</code>中的 <code>dispatch_async_safely_main_queue</code> 函数接受一个闭包 利用 NSThread.isMainThread 判断并将其放置在主线程中执行</p>
<h2 id="Kingfisher-swift"><a href="#Kingfisher-swift" class="headerlink" title="Kingfisher.swift"></a>Kingfisher.swift</h2><p>主要文件<code>ImageView+Kingfisher</code>,<code>KingfisherManager</code>,<code>ImageCache</code>,<code>ImageDownloader</code>,废话不多说直接代码学习</p>
<p>运行demo 下面有这么一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let url = URL(string:&quot;https://raw.githubusercontent.com/onevcat/Kingfisher/master/images/kingfisher-\(indexPath.row + 1).jpg&quot;)!</div><div class="line">(cell as! CollectionViewCell).cellImageView.kf.setImage(with: url,</div><div class="line">                                       placeholder: nil,</div><div class="line">                                       options: [.transition(.fade(1))],</div><div class="line">                                       progressBlock: &#123; receivedSize, totalSize in</div><div class="line">                                        print(&quot;\(indexPath.row + 1): \(receivedSize)/\(totalSize)&quot;)</div><div class="line">        &#125;,</div><div class="line">                                       completionHandler: &#123; image, error, cacheType, imageURL in</div><div class="line">                                        print(&quot;\(indexPath.row + 1): Finished&quot;)</div><div class="line">    &#125;)</div></pre></td></tr></table></figure></p>
<p>首先调用的<code>UIImageView</code>的<code>kf</code>属性 之前是调用<code>UIImageView</code>的<code>Extension</code>中的<code>kf_setImage</code> ,现已弃用  那<code>kf</code> 属性是如何实现的？<br>下面是<code>Kingfisher.swift</code>源码</p>
<ul>
<li>自定义了不同平台下的一些类型别名  swift中的typealias 相当于OC中的typedef</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#if os(macOS)</div><div class="line">    import AppKit</div><div class="line">    public typealias Image = NSImage</div><div class="line">    public typealias Color = NSColor</div><div class="line">    public typealias ImageView = NSImageView</div><div class="line">    typealias Button = NSButton</div><div class="line">#else</div><div class="line">    import UIKit</div><div class="line">    public typealias Image = UIImage</div><div class="line">    public typealias Color = UIColor</div><div class="line">    #if !os(watchOS)</div><div class="line">    public typealias ImageView = UIImageView</div><div class="line">    typealias Button = UIButton</div><div class="line">    #endif</div><div class="line">#endif</div></pre></td></tr></table></figure>
<ul>
<li>申明了泛型类Kingfisher 实现了一个简单构造器，其中上面的cellImageView就是base属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public final class Kingfisher&lt;Base&gt; &#123;</div><div class="line">    public let base: Base</div><div class="line">    public init(_ base: Base) &#123;</div><div class="line">        self.base = base</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>申明KingfisherCompatible协议 有一个可读属性kf 其类型是关联类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> A type that has Kingfisher extensions.</div><div class="line"> */</div><div class="line"></div><div class="line">public protocol KingfisherCompatible &#123;</div><div class="line">    associatedtype CompatibleType</div><div class="line">    var kf: CompatibleType &#123; get &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>KingfisherCompatible协议的实现 属性kf关联Kingfisher类型 返回一个Kingfisher实例 base 参数就是传入的self</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public extension KingfisherCompatible &#123;</div><div class="line">    public var kf: Kingfisher&lt;Self&gt; &#123;</div><div class="line">        get &#123; return Kingfisher(self) &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Image ImageView Button 遵守 KingfisherCompatible 协议 所以上边的self参数就是遵守了协议的类型 因此base属性即cellImageView</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">extension Image: KingfisherCompatible &#123; &#125;</div><div class="line">#if !os(watchOS)</div><div class="line">extension ImageView: KingfisherCompatible &#123;&#125;</div><div class="line">extension Button: KingfisherCompatible &#123; &#125;</div><div class="line">#endif</div></pre></td></tr></table></figure>
<h2 id="ImageView-Kingfisher"><a href="#ImageView-Kingfisher" class="headerlink" title="ImageView+Kingfisher"></a>ImageView+Kingfisher</h2><p>现在来说说<code>setImage</code>这个方法的实现 这个方法是在<code>Kingfisher</code>的Extension 中实现 并且要求<code>Base</code>属于<code>UIImageView</code>类型 即<code>where Base: ImageView</code> 由于<code>kf</code> 属性关联了<code>Kingfisher</code><br> 所以可以调用<code>(cell as! CollectionViewCell).cellImageView.kf.setImage</code><br>Extensions目录下的三个文件都是类似实现的 这里就以ImageView+Kingfisher.swift为例<br>下面方法是外部使用Kingfisher最频繁也是最重要的方法<br>第一个参数<code>Resource</code>是一个URL遵守的Protocol，一般传入图片的URL，不可为空<br>第二个参数<code>placeholder</code>是一个默认的占位图，可为空<br>第三个参数<code>KingfisherOptionsInfo</code> 是个枚举数组，配置Kingfisher下载图片的一些操作行为<br>第四个参数<code>DownloadProgressBlock</code>是个下载进度闭包，可以用于更新下载UI<br>第五个参数<code>completionHandler</code>是个下载完成闭包，闭包参数包含图片，错误，缓存类型，URL 信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div></pre></td><td class="code"><pre><div class="line">extension Kingfisher where Base: ImageView &#123;</div><div class="line">    /**</div><div class="line">     Set an image with a resource, a placeholder image, options, progress handler and completion handler.</div><div class="line">     </div><div class="line">     - parameter resource:          Resource object contains information such as `cacheKey` and `downloadURL`.</div><div class="line">     - parameter placeholder:       A placeholder image when retrieving the image at URL.</div><div class="line">     - parameter options:           A dictionary could control some behaviors. See `KingfisherOptionsInfo` for more.</div><div class="line">     - parameter progressBlock:     Called when the image downloading progress gets updated.</div><div class="line">     - parameter completionHandler: Called when the image retrieved and set.</div><div class="line">     </div><div class="line">     - returns: A task represents the retrieving process.</div><div class="line">     </div><div class="line">     - note: Both the `progressBlock` and `completionHandler` will be invoked in main thread.</div><div class="line">     The `CallbackDispatchQueue` specified in `optionsInfo` will not be used in callbacks of this method.</div><div class="line">     */</div><div class="line">    @discardableResult 忽略返回值警告</div><div class="line">    public func setImage(with resource: Resource?,</div><div class="line">                         placeholder: Image? = nil,</div><div class="line">                         options: KingfisherOptionsInfo? = nil,</div><div class="line">                         progressBlock: DownloadProgressBlock? = nil,</div><div class="line">                         completionHandler: CompletionHandler? = nil) -&gt; RetrieveImageTask</div><div class="line">    &#123;</div><div class="line">        当传入的resource为空时 使用guard语句提前退出 Resource是一个协议 URL遵守此协议 Resource有两个属性 cacheKey和downloadURL</div><div class="line">        guard let resource = resource else &#123;</div><div class="line">            base.image = placeholder</div><div class="line">            completionHandler?(nil, nil, .none, nil)</div><div class="line">            return .empty</div><div class="line">        &#125;</div><div class="line">        图片加载过程中是否显示placeholder</div><div class="line">        var options = options ?? KingfisherEmptyOptionsInfo</div><div class="line">        if !options.keepCurrentImageWhileLoading &#123;</div><div class="line">            base.image = placeholder</div><div class="line">        &#125;</div><div class="line">        如果indicator存在，开启转圈动画 indicator 通过属性关联存取</div><div class="line">        let maybeIndicator = indicator</div><div class="line">        maybeIndicator?.startAnimatingView()</div><div class="line">        关联属性绑定下载的URL</div><div class="line">        setWebURL(resource.downloadURL)</div><div class="line"></div><div class="line">        默认开启加载所有GIF图片数据，显示GIF 动态图片</div><div class="line">        if base.shouldPreloadAllGIF() &#123;</div><div class="line">            options.append(.preloadAllGIFData)</div><div class="line">        &#125;</div><div class="line">        调用KingfisherManager的方法来获取图片</div><div class="line">        let task = KingfisherManager.shared.retrieveImage(</div><div class="line">            with: resource,</div><div class="line">            options: options,</div><div class="line">            progressBlock: &#123; receivedSize, totalSize in</div><div class="line">                下载进度回调</div><div class="line">                if let progressBlock = progressBlock &#123;</div><div class="line">                    progressBlock(receivedSize, totalSize)</div><div class="line">                &#125;</div><div class="line">            &#125;,</div><div class="line">            completionHandler: &#123;[weak base] image, error, cacheType, imageURL in</div><div class="line">                确保线程安全</div><div class="line">                DispatchQueue.main.safeAsync &#123;</div><div class="line">                    确保返回的图片与URL对应一致</div><div class="line">                    guard let strongBase = base, imageURL == self.webURL else &#123;</div><div class="line">                        return</div><div class="line">                    &#125;</div><div class="line">                    self.setImageTask(nil)</div><div class="line">                    没有图片返回停止动画返回错误</div><div class="line">                    guard let image = image else &#123;</div><div class="line">                        maybeIndicator?.stopAnimatingView()</div><div class="line">                        completionHandler?(nil, error, cacheType, imageURL)</div><div class="line">                        return</div><div class="line">                    &#125;</div><div class="line">                    是否需要过渡动画 transitionItem 为 options中第一个.transition</div><div class="line">                    需要过渡动画需要满足以下情况</div><div class="line">                    1.transitionItem存在且不为.transition(.none)</div><div class="line">                    2.options.forceTransition存在 或者 cacheType == .none </div><div class="line">                    guard let transitionItem = options.firstMatchIgnoringAssociatedValue(.transition(.none)),</div><div class="line">                        case .transition(let transition) = transitionItem, ( options.forceTransition || cacheType == .none) else</div><div class="line">                    &#123;</div><div class="line">                        maybeIndicator?.stopAnimatingView()</div><div class="line">                        strongBase.image = image</div><div class="line">                        completionHandler?(image, error, cacheType, imageURL)</div><div class="line">                        return</div><div class="line">                    &#125;</div><div class="line">                    过渡动画</div><div class="line">                    #if !os(macOS)</div><div class="line">                        UIView.transition(with: strongBase, duration: 0.0, options: [],</div><div class="line">                                          animations: &#123; maybeIndicator?.stopAnimatingView() &#125;,</div><div class="line">                                          completion: &#123; _ in</div><div class="line">                                            UIView.transition(with: strongBase, duration: transition.duration,</div><div class="line">                                                              options: [transition.animationOptions, .allowUserInteraction],</div><div class="line">                                                              animations: &#123;</div><div class="line">                                                                // Set image property in the animation.</div><div class="line">                                                                设置图片，如果是自定义动画 在定义动画回调中设置图片，代码在ImageTransition.swift</div><div class="line">                                                                transition.animations?(strongBase, image)</div><div class="line">                                                              &#125;,</div><div class="line">                                                              completion: &#123; finished in</div><div class="line">                                                                动画结束回调</div><div class="line">                                                                transition.completion?(finished)</div><div class="line">                                                                completionHandler?(image, error, cacheType, imageURL)</div><div class="line">                                                              &#125;)</div><div class="line">                                          &#125;)</div><div class="line">                    #endif</div><div class="line">                &#125;</div><div class="line">            &#125;)</div><div class="line">        setImageTask(task)</div><div class="line">   return task</div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">     Cancel the image download task bounded to the image view if it is running.</div><div class="line">     Nothing will happen if the downloading has already finished.</div><div class="line">     */</div><div class="line">    取消下载</div><div class="line">    public func cancelDownloadTask() &#123;</div><div class="line">        imageTask?.downloadTask?.cancel()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>ImageView+Kingfisher</code> 中的<code>WebUR</code> ，<code>indicatorType</code> ，<code>indicator</code>， <code>imageTask</code> 属性均使用属性关联技术实现数据的存取 </p>
<h2 id="KingfisherManager"><a href="#KingfisherManager" class="headerlink" title="KingfisherManager"></a>KingfisherManager</h2><p>该类是<code>Kingfisher</code>唯一的一个管理调度类。这个类有下载和缓存两大功能模块 主要包含了两个属性 两个方法<br>  <code>public var cache: ImageCache</code> 图片缓存属性<br> <code>public var downloader: ImageDownloader</code>  图片下载属性<br> <code>func downloadAndCacheImage</code> 下载并且缓存图片方法<br><code>func tryToRetrieveImageFromCache</code> 获取缓存图片</p>
<p>在<code>ImageView+Kingfisher</code>中最后图片的获取就是由<code>KingfisherManager</code>的单例实现的<code>retrieveImage</code></p>
<ul>
<li>外部调用获取图片方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">func retrieveImage(with resource: Resource,</div><div class="line">        options: KingfisherOptionsInfo?,</div><div class="line">        progressBlock: DownloadProgressBlock?,</div><div class="line">        completionHandler: CompletionHandler?) -&gt; RetrieveImageTask&#123;</div><div class="line">        let task = RetrieveImageTask()</div><div class="line">        if let options = options, options.forceRefresh &#123;</div><div class="line">             强制刷新 从网络获取图片</div><div class="line">            _ = downloadAndCacheImage(</div><div class="line">                with: resource.downloadURL,</div><div class="line">                forKey: resource.cacheKey,</div><div class="line">                retrieveImageTask: task,</div><div class="line">                progressBlock: progressBlock,</div><div class="line">                completionHandler: completionHandler,</div><div class="line">                options: options)</div><div class="line">        &#125; else &#123;</div><div class="line">            从缓存获取图片</div><div class="line">            tryToRetrieveImageFromCache(</div><div class="line">                forKey: resource.cacheKey,</div><div class="line">                with: resource.downloadURL,</div><div class="line">                retrieveImageTask: task,</div><div class="line">                progressBlock: progressBlock,</div><div class="line">                completionHandler: completionHandler,</div><div class="line">                options: options)</div><div class="line">        &#125;</div><div class="line">        return task</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>下载并且缓存图片的方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">func downloadAndCacheImage(with url: URL,</div><div class="line">                          forKey key: String,</div><div class="line">                   retrieveImageTask: RetrieveImageTask,</div><div class="line">                       progressBlock: DownloadProgressBlock?,</div><div class="line">                   completionHandler: CompletionHandler?,</div><div class="line">                             options: KingfisherOptionsInfo?) -&gt; RetrieveImageDownloadTask?</div><div class="line"> &#123;</div><div class="line">     获取下载器 并开启下载 </div><div class="line">     let options = options ?? KingfisherEmptyOptionsInfo</div><div class="line">     let downloader = options.downloader</div><div class="line">     return downloader.downloadImage(with: url, retrieveImageTask: retrieveImageTask, options: options,</div><div class="line">         progressBlock: &#123; receivedSize, totalSize in</div><div class="line">             progressBlock?(receivedSize, totalSize)</div><div class="line">         &#125;,</div><div class="line">         completionHandler: &#123; image, error, imageURL, originalData in</div><div class="line"></div><div class="line">             let targetCache = options.targetCache</div><div class="line">             if let error = error, error.code == KingfisherError.notModified.rawValue &#123;</div><div class="line">                 // Not modified. Try to find the image from cache.</div><div class="line">                 // (The image should be in cache. It should be guaranteed by the framework users.)</div><div class="line">                如果有错误并且没有修改过URL 返回缓存图片</div><div class="line">                 targetCache.retrieveImage(forKey: key, options: options, completionHandler: &#123; (cacheImage, cacheType) -&gt; () in</div><div class="line">                     completionHandler?(cacheImage, nil, cacheType, url)</div><div class="line">                 &#125;)</div><div class="line">                 return</div><div class="line">             &#125;</div><div class="line">             缓存图片 </div><div class="line">             if let image = image, let originalData = originalData &#123;</div><div class="line">                 targetCache.store(image,</div><div class="line">                                   original: originalData,</div><div class="line">                                   forKey: key,</div><div class="line">                                   processorIdentifier:options.processor.identifier,</div><div class="line">                                   cacheSerializer: options.cacheSerializer,</div><div class="line">                                   toDisk: !options.cacheMemoryOnly,</div><div class="line">                                   completionHandler: nil)</div><div class="line">             &#125;</div><div class="line"></div><div class="line">             completionHandler?(image, error, .none, url)</div><div class="line"></div><div class="line">         &#125;)</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<ul>
<li>优先从缓存获取图片，如缓存中没有，在从网络获取图片</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">func tryToRetrieveImageFromCache(forKey key: String,</div><div class="line">                                   with url: URL,</div><div class="line">                          retrieveImageTask: RetrieveImageTask,</div><div class="line">                              progressBlock: DownloadProgressBlock?,</div><div class="line">                          completionHandler: CompletionHandler?,</div><div class="line">                                    options: KingfisherOptionsInfo?)</div><div class="line">&#123;</div><div class="line">    打破下面diskTask内部闭包保持的循环引用，完成之后取消磁盘任务引用，避免循环引用，释放内存</div><div class="line">    let diskTaskCompletionHandler: CompletionHandler = &#123; (image, error, cacheType, imageURL) -&gt; () in</div><div class="line">        // Break retain cycle created inside diskTask closure below</div><div class="line">        retrieveImageTask.diskRetrieveTask = nil</div><div class="line">        completionHandler?(image, error, cacheType, imageURL)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    let targetCache = options?.targetCache ?? cache</div><div class="line">    let diskTask = targetCache.retrieveImage(forKey: key, options: options,</div><div class="line">        completionHandler: &#123; image, cacheType in</div><div class="line">            if image != nil &#123;</div><div class="line">                 成功返回图片</div><div class="line">                diskTaskCompletionHandler(image, nil, cacheType, url)</div><div class="line">            &#125; else if let options = options, options.onlyFromCache &#123;</div><div class="line">                返回失败 并且设置只从缓存获取图片 返回没有缓存错误</div><div class="line">                let error = NSError(domain: KingfisherErrorDomain, code: KingfisherError.notCached.rawValue, userInfo: nil)</div><div class="line">                diskTaskCompletionHandler(nil, error, .none, url)</div><div class="line">            &#125; else &#123;</div><div class="line">                返回失败 再从网络下载图片</div><div class="line">                self.downloadAndCacheImage(</div><div class="line">                    with: url,</div><div class="line">                    forKey: key,</div><div class="line">                    retrieveImageTask: retrieveImageTask,</div><div class="line">                    progressBlock: progressBlock,</div><div class="line">                    completionHandler: diskTaskCompletionHandler,</div><div class="line">                    options: options)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    )</div><div class="line">    retrieveImageTask.diskRetrieveTask = diskTask</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="KingfisherOptionsInfo"><a href="#KingfisherOptionsInfo" class="headerlink" title="KingfisherOptionsInfo"></a>KingfisherOptionsInfo</h2><p>上面代码多次用到<code>options</code>这个参数，它的参数类型是<code>KingfisherOptionsInfo</code>是一个类型别名<br><code>public typealias KingfisherOptionsInfo = [KingfisherOptionsInfoItem]</code><br><code>KingfisherOptionsInfoItem</code> 是一个枚举 配置 <code>Kingfisher</code> 所有功能行为 下面是详细中文注释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">public enum KingfisherOptionsInfoItem &#123;</div><div class="line"></div><div class="line">    这个成员的关联值是一个ImageCache对象。 Kingfisher使用指定的缓存对象处理 相关业务,包括试图检索缓存图像和存储下载的图片。</div><div class="line">    case targetCache(ImageCache)</div><div class="line"></div><div class="line">    这个成员的关联值应该是一个ImageDownloader对象。Kingfisher将使用这个下载器下载的图片。</div><div class="line">    case downloader(ImageDownloader)</div><div class="line"></div><div class="line">    如果从网络下载的图片 Kingfisher将使用“ImageTransition这个枚举动画。从内存或磁盘缓存时默认过渡不会发生。如果需要,设置ForceTransition</div><div class="line">    case transition(ImageTransition)</div><div class="line"></div><div class="line">    有关“浮动”值将被设置为图像下载任务的优先级。值在0.0 ~ 1.0之间。如果没有设置这个选项,默认值(“NSURLSessionTaskPriorityDefault”)将被使用。</div><div class="line">    case downloadPriority(Float)</div><div class="line"></div><div class="line">    如果设置,将忽略缓存,开启一个下载任务的资源</div><div class="line">    case forceRefresh</div><div class="line">    </div><div class="line">    如果设置 即使缓存的图片也将开启过渡动画</div><div class="line">    case forceTransition</div><div class="line"></div><div class="line">    如果设置，Kingfisher只会在内存中缓存值而不是磁盘</div><div class="line">    case cacheMemoryOnly</div><div class="line"></div><div class="line">    如果设置 Kingfisher只会从缓存中加载图片</div><div class="line">    case onlyFromCache</div><div class="line">    </div><div class="line">    在使用之前在后台线程解码图像</div><div class="line">    case backgroundDecode</div><div class="line">    </div><div class="line">    当从缓存检索图像时 这个成员的关联值将被用作目标队列的调度时回调。如果没 有设置, Kingfisher将使用主要quese回调</div><div class="line">    case callbackDispatchQueue(DispatchQueue?)</div><div class="line">    </div><div class="line">    将检索到的图片数据转换成一个图时 这个成员变量将被用作图片缩放因子。图像分辨率,而不是屏幕尺寸。你可能处理时需要指定正确的缩放因子@2x或@3x Retina图像。</div><div class="line">    case scaleFactor(CGFloat)</div><div class="line">    </div><div class="line">    是否所有的GIF应该加载数据。默认false，只显示GIF中第一张图片。如果true,所有的GIF数据将被加载到内存中进行解码。这个选项主要是用于内部的兼容性。你不应该把直接设置它。“AnimatedImageView”不会预加载所有数据,而一个正常的图像视图(“UIImageView”或“NSImageView”)将加载所有数据。选择使用相应的图像视图类型而不是设置这个选项。</div><div class="line">    case preloadAllGIFData</div><div class="line">  </div><div class="line">    发送请求之前用于改变请求。这是最后的机会你可以修改请求。您可以修改请求一些定制的目的,如添加身份验证令牌头,进行基本的HTTP身份验证或类似的url映射。原始请求默认情况下将没有任何修改</div><div class="line">    case requestModifier(ImageDownloadRequestModifier)</div><div class="line">    </div><div class="line">    下载完成时,处理器会将下载的数据转换为一个图像。如果缓存连接到下载器(当你正在使用KingfisherManager或图像扩展方法),转换后的图像也将被缓存</div><div class="line">    case processor(ImageProcessor)</div><div class="line">    </div><div class="line">    提供一个CacheSerializer 可用于图像对象序列化成图像数据存储到磁盘缓存和从磁盘缓存将图片数据反序列化成图像对象</div><div class="line">    case cacheSerializer(CacheSerializer)</div><div class="line">    </div><div class="line">    保持现有的图像同时设置另一个图像图像视图。通过设置这个选项,imageview的placeholder参数将被忽略和当前图像保持同时加载新图片</div><div class="line">    case keepCurrentImageWhileLoading</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是自定义&lt;== 运算符 比较两个KingfisherOptionsInfoItem 是否相等 相等返回true 否则返回false</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">precedencegroup ItemComparisonPrecedence &#123;</div><div class="line">    associativity: none</div><div class="line">    higherThan: LogicalConjunctionPrecedence</div><div class="line">&#125;</div><div class="line"></div><div class="line">infix operator &lt;== : ItemComparisonPrecedence</div><div class="line"></div><div class="line">// This operator returns true if two `KingfisherOptionsInfoItem` enum is the same, without considering the associated values.</div><div class="line">func &lt;== (lhs: KingfisherOptionsInfoItem, rhs: KingfisherOptionsInfoItem) -&gt; Bool &#123;</div><div class="line">    switch (lhs, rhs) &#123;</div><div class="line">    case (.targetCache(_), .targetCache(_)): return true</div><div class="line">    case (.downloader(_), .downloader(_)): return true</div><div class="line">    case (.transition(_), .transition(_)): return true</div><div class="line">    case (.downloadPriority(_), .downloadPriority(_)): return true</div><div class="line">    case (.forceRefresh, .forceRefresh): return true</div><div class="line">    case (.forceTransition, .forceTransition): return true</div><div class="line">    case (.cacheMemoryOnly, .cacheMemoryOnly): return true</div><div class="line">    case (.onlyFromCache, .onlyFromCache): return true</div><div class="line">    case (.backgroundDecode, .backgroundDecode): return true</div><div class="line">    case (.callbackDispatchQueue(_), .callbackDispatchQueue(_)): return true</div><div class="line">    case (.scaleFactor(_), .scaleFactor(_)): return true</div><div class="line">    case (.preloadAllGIFData, .preloadAllGIFData): return true</div><div class="line">    case (.requestModifier(_), .requestModifier(_)): return true</div><div class="line">    case (.processor(_), .processor(_)): return true</div><div class="line">    case (.cacheSerializer(_), .cacheSerializer(_)): return true</div><div class="line">    case (.keepCurrentImageWhileLoading, .keepCurrentImageWhileLoading): return true</div><div class="line">    default: return false</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是对<code>CollectionType</code>的一个扩展 返回匹配的第一个相同枚举值  上面过渡动画就有用到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public extension Collection where Iterator.Element == KingfisherOptionsInfoItem &#123;</div><div class="line">    func firstMatchIgnoringAssociatedValue(_ target: Iterator.Element) -&gt; Iterator.Element? &#123;</div><div class="line">        return index &#123; $0 &lt;== target &#125;.flatMap &#123; self[$0] &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    func removeAllMatchesIgnoringAssociatedValue(_ target: Iterator.Element) -&gt; [Iterator.Element] &#123;</div><div class="line">        return self.filter &#123; !($0 &lt;== target) &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>KingfisherOptionsInfo</code>中有很多的类似的属性get方法 如下是关于图片编码的，默认返回<code>DefaultCacheSerializer.default</code>。如果要自定义图片编码，可以添加自定义<code>CacheSerializer</code> 到<code>Options</code>数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public var cacheSerializer: CacheSerializer &#123;</div><div class="line">     if let item = firstMatchIgnoringAssociatedValue(.cacheSerializer(DefaultCacheSerializer.default)),</div><div class="line">         case .cacheSerializer(let cacheSerializer) = item</div><div class="line">     &#123;</div><div class="line">         return cacheSerializer</div><div class="line">     &#125;</div><div class="line">     return DefaultCacheSerializer.default</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>至此，我们对Kingfisher对整体架构已经有比较清晰的认识了 如下图所示</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1618300-a79657ce3f76775f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Kingfisher.png"></p>
<p>由于源代码比较多，一些注释都写在代码部分，可能看起来有点怪 用简书也有段时间，但这还是第一次自己写文章  接下来我会继续学习下载模块和缓存模块的过程等等 如有错误，希望大家不吝指正</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Kingfisher 3.x 学习（二）]]></title>
      <url>http://ChenAo0727.github.io/2016/12/26/Kingfisher2/</url>
      <content type="html"><![CDATA[<h2 id="ImageDownloader"><a href="#ImageDownloader" class="headerlink" title="ImageDownloader"></a>ImageDownloader</h2><p>在<code>Kingfisher</code> 中，该类主要负责图片的网络下载，其实现原理是基于系统的<code>URLSession</code> ,实现它的代理方法。下面是几个主要部分：</p>
<ul>
<li>ImageFetchLoad</li>
<li>URLSession的配置</li>
<li>下载方法</li>
<li>取消下载</li>
<li>URLSession 代理方法</li>
<li>下载某张特定图片<a id="more"></a>
</li>
</ul>
<h3 id="ImageFetchLoad"><a href="#ImageFetchLoad" class="headerlink" title="ImageFetchLoad"></a>ImageFetchLoad</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class ImageFetchLoad &#123;</div><div class="line">     var contents = [(callback: CallbackPair, options: KingfisherOptionsInfo)]()</div><div class="line">     var responseData = NSMutableData()</div><div class="line">     var downloadTaskCount = 0</div><div class="line">     var downloadTask: RetrieveImageDownloadTask?</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p><code>ImageFetchLoad</code> 是一个嵌套类。它处理了一个<code>URL</code> 下载数据，能够记录同一个<code>URL</code>下载任务次数。其中的<code>contents</code> 属性是一个元组数组，该元组包含两个部分：<code>CallbackPair</code> ，<code>KingfisherOptionsInfo</code> 。<code>KingfisherOptionsInfo</code> 就是传入的配置参数，而 <code>CallbackPair</code> 也是一个元组，它包含了传入的两个闭包。<code>ImageDownloaderProgressBlock</code> 能够在每次接收到数据时调用，可以用来显示进度条，<code>ImageDownloaderCompletionHandler</code> 在数据接收完成之后会被调用。里面还有一个<code>responseData</code> 属性,能够把每次获取到的数据存储起来。那么 <code>ImageDownloader</code> 这个类有什么作用呢？通常情况下，<code>ImageDownloader</code> 往往要处理多个 <code>URL</code> 的下载任务，它的 <code>fetchLoads</code> 属性是一个 <code>[URL: ImageFetchLoad]</code> 类型的字典，存储不同 <code>URL</code> 及其 <code>ImageFetchLoad</code> 之间的对应关系。<br> 下面是根据 <code>URL</code> 获取 <code>ImageFetchLoad</code> 的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">func fetchLoad(for url: URL) -&gt; ImageFetchLoad? &#123;</div><div class="line">    var fetchLoad: ImageFetchLoad?</div><div class="line">    barrierQueue.sync &#123; fetchLoad = fetchLoads[url] &#125;</div><div class="line">    return fetchLoad</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里使用 <code>barrierQueue</code> 来操作，利用 <code>sync</code> 阻塞当前线程，完成 <code>ImageFetchLoad</code> 读操作后再返回。这样当读取 <code>ImageFetchLoad</code> 的时候，保证ImageFetchLoad 不会同时在被写,导致数据错误</p>
<h3 id="URLSession的配置"><a href="#URLSession的配置" class="headerlink" title="URLSession的配置"></a>URLSession的配置</h3><p>来看一下 <code>ImageDownloader</code> 的构造器方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public init(name: String) &#123;</div><div class="line">        if name.isEmpty &#123;</div><div class="line">            fatalError(&quot;[Kingfisher] You should specify a name for the downloader. A downloader with empty name is not permitted.&quot;)</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        barrierQueue = DispatchQueue(label: &quot;com.onevcat.Kingfisher.ImageDownloader.Barrier.\\(name)&quot;, attributes: .concurrent)</div><div class="line">        processQueue = DispatchQueue(label: &quot;com.onevcat.Kingfisher.ImageDownloader.Process.\\(name)&quot;, attributes: .concurrent)</div><div class="line">   </div><div class="line">        sessionHandler = ImageDownloaderSessionHandler()</div><div class="line">        // Provide a default implement for challenge responder.</div><div class="line">        authenticationChallengeResponder = sessionHandler</div><div class="line">        session = URLSession(configuration: sessionConfiguration, delegate: sessionHandler, delegateQueue: .main)</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看到 <code>session</code> 是 <code>sessionConfiguration</code> 和 <code>sessionHandler</code> 来配置的。其中<code>sessionConfiguration</code> 是个 <code>open</code> 的属性，可以在外部自定义。 <code>delegate</code> 确不是<code>ImageDownloader</code> 而是 <code>sessionHandler</code><br> 这里喵神也有解释，以前确实是 <code>ImageDownloader</code> 作为代理的，但会造成内存泄漏 <a href="https://github.com/onevcat/Kingfisher/issues/235" target="_blank" rel="external">issue</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/// Delegate class for `NSURLSessionTaskDelegate`.</div><div class="line">/// The session object will hold its delegate until it gets invalidated.</div><div class="line">/// If we use `ImageDownloader` as the session delegate, it will not be released.</div><div class="line">/// So we need an additional handler to break the retain cycle.</div></pre></td></tr></table></figure>
<h3 id="下载方法"><a href="#下载方法" class="headerlink" title="下载方法"></a>下载方法</h3><p>这是外部调用 <code>ImageDownloader</code> 最常用的方法 配置好请求参数：Time 、URL、 URLRequest ，确保请求的前提条件 主要是 <code>setup</code> 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">func downloadImage(with url: URL,</div><div class="line">              retrieveImageTask: RetrieveImageTask?,</div><div class="line">                        options: KingfisherOptionsInfo?,</div><div class="line">                  progressBlock: ImageDownloaderProgressBlock?,</div><div class="line">              completionHandler: ImageDownloaderCompletionHandler?) -&gt; RetrieveImageDownloadTask?</div><div class="line">    &#123;</div><div class="line">        if let retrieveImageTask = retrieveImageTask, retrieveImageTask.cancelledBeforeDownloadStarting &#123;</div><div class="line">            return nil</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        let timeout = self.downloadTimeout == 0.0 ? 15.0 : self.downloadTimeout</div><div class="line">        </div><div class="line">        // We need to set the URL as the load key. So before setup progress, we need to ask the `requestModifier` for a final URL.</div><div class="line">        var request = URLRequest(url: url, cachePolicy: .reloadIgnoringLocalCacheData, timeoutInterval: timeout)</div><div class="line">        request.httpShouldUsePipelining = requestsUsePipeling</div><div class="line"></div><div class="line">        if let modifier = options?.modifier &#123;</div><div class="line">            guard let r = modifier.modified(for: request) else &#123;</div><div class="line">                completionHandler?(nil, NSError(domain: KingfisherErrorDomain, code: KingfisherError.downloadCancelledBeforeStarting.rawValue, userInfo: nil), nil, nil)</div><div class="line">                return nil</div><div class="line">            &#125;</div><div class="line">            request = r</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // There is a possiblility that request modifier changed the url to `nil` or empty.</div><div class="line">        guard let url = request.url, !url.absoluteString.isEmpty else &#123;</div><div class="line">            completionHandler?(nil, NSError(domain: KingfisherErrorDomain, code: KingfisherError.invalidURL.rawValue, userInfo: nil), nil, nil)</div><div class="line">            return nil</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        var downloadTask: RetrieveImageDownloadTask?</div><div class="line">         setup &#123;...&#125;</div><div class="line">        return downloadTask</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p> <code>setup</code> 闭包回调: 根据传过来的 <code>fetchLoad</code> 是否开启下载任务。若没有根据 <code>session</code> 生成 <code>dataTask</code> ,在进一步包装成 <code>RetrieveImageDownloadTask</code> ，传给 <code>fetchLoad</code> 的 <code>downloadTask</code> 属性 配置好任务优先级，开启下载任务，如果已开启下载，下载次数加1，设置传给外部的 <code>retrieveImageTask</code> 的 <code>downloadTask</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">setup(progressBlock: progressBlock, with: completionHandler, for: url, options: options) &#123;(session, fetchLoad) -&gt; Void in</div><div class="line">     if fetchLoad.downloadTask == nil &#123;</div><div class="line">         let dataTask = session.dataTask(with: request)</div><div class="line">         //设置下载任务</div><div class="line">         fetchLoad.downloadTask = RetrieveImageDownloadTask(internalTask: dataTask, ownerDownloader: self)</div><div class="line">         //设置下载任务优先级</div><div class="line">         dataTask.priority = options?.downloadPriority ?? URLSessionTask.defaultPriority</div><div class="line">          //开启下载任务</div><div class="line">         dataTask.resume()</div><div class="line">         </div><div class="line">         // Hold self while the task is executing.</div><div class="line">        //下载期间确保sessionHandler 持有 ImageDownloader</div><div class="line">         self.sessionHandler.downloadHolder = self</div><div class="line">     &#125;</div><div class="line">     //下载次数加1</div><div class="line">     fetchLoad.downloadTaskCount += 1</div><div class="line">     downloadTask = fetchLoad.downloadTask</div><div class="line">     retrieveImageTask?.downloadTask = downloadTask</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// A single key may have multiple callbacks. Only download once.</div><div class="line"> func setup(progressBlock: ImageDownloaderProgressBlock?, with completionHandler: ImageDownloaderCompletionHandler?, for url: URL, options: KingfisherOptionsInfo?, started: ((URLSession, ImageFetchLoad) -&gt; Void)) &#123;</div><div class="line"></div><div class="line">     barrierQueue.sync(flags: .barrier) &#123;</div><div class="line">         let loadObjectForURL = fetchLoads[url] ?? ImageFetchLoad()</div><div class="line">         let callbackPair = (progressBlock: progressBlock, completionHandler: completionHandler)</div><div class="line">         </div><div class="line">         loadObjectForURL.contents.append((callbackPair, options ?? KingfisherEmptyOptionsInfo))</div><div class="line">         </div><div class="line">         fetchLoads[url] = loadObjectForURL</div><div class="line">         </div><div class="line">         if let session = session &#123;</div><div class="line">             started(session, loadObjectForURL)</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>首先 <code>barrierQueue.sync</code> 确保 <code>ImageFetchLoad</code> 读写安全，根据传入的 <code>URL</code> 获取对应的<code>ImageFetchLoad</code> 设置 <code>callbackPair</code> 并更新 <code>contents</code> ，开启下载 </p>
<h3 id="取消下载"><a href="#取消下载" class="headerlink" title="取消下载"></a>取消下载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">func cancelDownloadingTask(_ task: RetrieveImageDownloadTask) &#123;</div><div class="line">      barrierQueue.sync &#123;</div><div class="line">          if let URL = task.internalTask.originalRequest?.url, let imageFetchLoad = self.fetchLoads[URL] &#123;</div><div class="line">              更新下载次数</div><div class="line">              imageFetchLoad.downloadTaskCount -= 1</div><div class="line">              if imageFetchLoad.downloadTaskCount == 0 &#123;</div><div class="line">                  task.internalTask.cancel()</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h3 id="URLSession-代理方法"><a href="#URLSession-代理方法" class="headerlink" title="URLSession 代理方法"></a>URLSession 代理方法</h3><ul>
<li>下载过程中接收Response</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive response: URLResponse, completionHandler: @escaping (URLSession.ResponseDisposition) -&gt; Void) &#123;</div><div class="line">       //下载过程中确保ImageDownloader 一直持有 </div><div class="line">       guard let downloader = downloadHolder else &#123;</div><div class="line">           completionHandler(.cancel)</div><div class="line">           return</div><div class="line">       &#125;</div><div class="line">        //返回状态码判断 </div><div class="line">       if let statusCode = (response as? HTTPURLResponse)?.statusCode,</div><div class="line">          let url = dataTask.originalRequest?.url,</div><div class="line">           !(downloader.delegate ?? downloader).isValidStatusCode(statusCode, for: downloader)</div><div class="line">       &#123;</div><div class="line">           let error = NSError(domain: KingfisherErrorDomain,</div><div class="line">                               code: KingfisherError.invalidStatusCode.rawValue,</div><div class="line">                               userInfo: [KingfisherErrorStatusCodeKey: statusCode, NSLocalizedDescriptionKey: HTTPURLResponse.localizedString(forStatusCode: statusCode)])</div><div class="line">            //返回错误 首先清除ImageFetchLoad </div><div class="line">           callCompletionHandlerFailure(error: error, url: url)</div><div class="line">       &#125;</div><div class="line">       //继续请求数据</div><div class="line">       completionHandler(.allow)</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li>下载过程中接收到数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data) &#123;</div><div class="line">    guard let downloader = downloadHolder else &#123;</div><div class="line">        return</div><div class="line">    &#125;</div><div class="line">    //添加数据到指定ImageFetchLoad</div><div class="line">    if let url = dataTask.originalRequest?.url, let fetchLoad = downloader.fetchLoad(for: url) &#123;</div><div class="line">        fetchLoad.responseData.append(data)</div><div class="line">        //下载进度回调</div><div class="line">        if let expectedLength = dataTask.response?.expectedContentLength &#123;</div><div class="line">            for content in fetchLoad.contents &#123;</div><div class="line">                DispatchQueue.main.async &#123;</div><div class="line">                    content.callback.progressBlock?(Int64(fetchLoad.responseData.length), expectedLength)</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>下载结束</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?) &#123;</div><div class="line">    // URL 一致性判断</div><div class="line">    guard let url = task.originalRequest?.url else &#123;</div><div class="line">        return</div><div class="line">    &#125;</div><div class="line">    // error 判断</div><div class="line">    guard error == nil else &#123;</div><div class="line">        callCompletionHandlerFailure(error: error!, url: url)</div><div class="line">        return</div><div class="line">    &#125;</div><div class="line">    //图片处理</div><div class="line">    processImage(for: task, url: url)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>会话需要认证 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">func urlSession(_ session: URLSession, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -&gt; Void) &#123;</div><div class="line">    guard let downloader = downloadHolder else &#123;</div><div class="line">        return</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    downloader.authenticationChallengeResponder?.downloader(downloader, didReceive: challenge, completionHandler: completionHandler)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>协议AuthenticationChallengeResponsable 处理会话认证 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public protocol AuthenticationChallengeResponsable: class &#123;</div><div class="line">    /**</div><div class="line">     Called when an session level authentication challenge is received.</div><div class="line">     This method provide a chance to handle and response to the authentication challenge before downloading could start.</div><div class="line">     </div><div class="line">     - parameter downloader:        The downloader which receives this challenge.</div><div class="line">     - parameter challenge:         An object that contains the request for authentication.</div><div class="line">     - parameter completionHandler: A handler that your delegate method must call.</div><div class="line">     </div><div class="line">     - Note: This method is a forward from `URLSession(:didReceiveChallenge:completionHandler:)`. Please refer to the document of it in `NSURLSessionDelegate`.</div><div class="line">     */</div><div class="line">    func downloader(_ downloader: ImageDownloader, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -&gt; Void)</div><div class="line">&#125;</div><div class="line"></div><div class="line">extension AuthenticationChallengeResponsable &#123;</div><div class="line">    </div><div class="line">    func downloader(_ downloader: ImageDownloader, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -&gt; Void) &#123;</div><div class="line">    </div><div class="line">        if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust &#123;</div><div class="line">            if let trustedHosts = downloader.trustedHosts, trustedHosts.contains(challenge.protectionSpace.host) &#123;</div><div class="line">                let credential = URLCredential(trust: challenge.protectionSpace.serverTrust!)</div><div class="line">                completionHandler(.useCredential, credential)</div><div class="line">                return</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        completionHandler(.performDefaultHandling, nil)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>返回错误信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">private func callCompletionHandlerFailure(error: Error, url: URL) &#123;</div><div class="line">     guard let downloader = downloadHolder, let fetchLoad = downloader.fetchLoad(for: url) else &#123;</div><div class="line">         return</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     // We need to clean the fetch load first, before actually calling completion handler.</div><div class="line">        //清除ImageDownloader</div><div class="line">     cleanFetchLoad(for: url)</div><div class="line">  </div><div class="line">     for content in fetchLoad.contents &#123;</div><div class="line">         content.options.callbackDispatchQueue.safeAsync &#123;</div><div class="line">             content.callback.completionHandler?(nil, error as NSError, url, nil)</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<ul>
<li>处理图片数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">private func processImage(for task: URLSessionTask, url: URL) &#123;</div><div class="line"></div><div class="line">    guard let downloader = downloadHolder else &#123;</div><div class="line">        return</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // We are on main queue when receiving this.</div><div class="line">    downloader.processQueue.async &#123;</div><div class="line">        </div><div class="line">        guard let fetchLoad = downloader.fetchLoad(for: url) else &#123;</div><div class="line">            return</div><div class="line">        &#125;</div><div class="line">        //首先清除ImageDownloader</div><div class="line">        self.cleanFetchLoad(for: url)</div><div class="line">        </div><div class="line">        let data = fetchLoad.responseData as Data</div><div class="line">        </div><div class="line">        // Cache the processed images. So we do not need to re-process the image if using the same processor.</div><div class="line">        // Key is the identifier of processor.</div><div class="line">        var imageCache: [String: Image] = [:]</div><div class="line">        for content in fetchLoad.contents &#123;</div><div class="line">            </div><div class="line">            let options = content.options</div><div class="line">            let completionHandler = content.callback.completionHandler</div><div class="line">            let callbackQueue = options.callbackDispatchQueue</div><div class="line">            </div><div class="line">            let processor = options.processor</div><div class="line">            </div><div class="line">            var image = imageCache[processor.identifier]</div><div class="line">            if image == nil &#123;</div><div class="line">               //合成图片</div><div class="line">                image = processor.process(item: .data(data), options: options)</div><div class="line">                </div><div class="line">                // Add the processed image to cache. </div><div class="line">                // If `image` is nil, nothing will happen (since the key is not existing before).</div><div class="line">                imageCache[processor.identifier] = image</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            if let image = image &#123;</div><div class="line">                 </div><div class="line">                downloader.delegate?.imageDownloader(downloader, didDownload: image, for: url, with: task.response)</div><div class="line">                </div><div class="line">                if options.backgroundDecode &#123;</div><div class="line">                   //后台编码</div><div class="line">                    let decodedImage = image.kf.decoded(scale: options.scaleFactor)</div><div class="line">                    callbackQueue.safeAsync &#123; completionHandler?(decodedImage, nil, url, data) &#125;</div><div class="line">                &#125; else &#123;</div><div class="line">                    callbackQueue.safeAsync &#123; completionHandler?(image, nil, url, data) &#125;</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">            &#125; else &#123;</div><div class="line">                 // 304 状态码 没有图像数据下载</div><div class="line">                if let res = task.response as? HTTPURLResponse , res.statusCode == 304 &#123;</div><div class="line">                    let notModified = NSError(domain: KingfisherErrorDomain, code: KingfisherError.notModified.rawValue, userInfo: nil)</div><div class="line">                    completionHandler?(nil, notModified, url, nil)</div><div class="line">                    continue</div><div class="line">                &#125;</div><div class="line">                 //返回不是图片数据 或者数据被破坏</div><div class="line">                let badData = NSError(domain: KingfisherErrorDomain, code: KingfisherError.badData.rawValue, userInfo: nil)</div><div class="line">                callbackQueue.safeAsync &#123; completionHandler?(nil, badData, url, nil) &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Data-&gt;Image 方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">static func image(data: Data, scale: CGFloat, preloadAllGIFData: Bool) -&gt; Image? &#123;</div><div class="line">       var image: Image?</div><div class="line">       </div><div class="line">       #if os(macOS)</div><div class="line">           switch data.kf.imageFormat &#123;</div><div class="line">           case .JPEG: image = Image(data: data)</div><div class="line">           case .PNG: image = Image(data: data)</div><div class="line">           case .GIF: image = Kingfisher&lt;Image&gt;.animated(with: data, scale: scale, duration: 0.0, preloadAll: preloadAllGIFData)</div><div class="line">           case .unknown: image = Image(data: data)</div><div class="line">           &#125;</div><div class="line">       #else</div><div class="line">           switch data.kf.imageFormat &#123;</div><div class="line">           case .JPEG: image = Image(data: data, scale: scale)</div><div class="line">           case .PNG: image = Image(data: data, scale: scale)</div><div class="line">           case .GIF: image = Kingfisher&lt;Image&gt;.animated(with: data, scale: scale, duration: 0.0, preloadAll: preloadAllGIFData)</div><div class="line">           case .unknown: image = Image(data: data, scale: scale)</div><div class="line">           &#125;</div><div class="line">       #endif</div><div class="line">       </div><div class="line">       return image</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h3 id="下载某张特定图片"><a href="#下载某张特定图片" class="headerlink" title="下载某张特定图片"></a>下载某张特定图片</h3><p>在 <code>ImageDownloader</code> 中有一个 <code>delegate</code> 属性 <code>open weak var delegate:ImageDownloaderDelegate?</code><br>你可以创建一个 <code>ImageDownloader</code> ,设置好delegate，调用下面方法，并且实现代理方法，就能下载这张图片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">open func downloadImage(with url: URL,</div><div class="line">                         options: KingfisherOptionsInfo? = nil,</div><div class="line">                         progressBlock: ImageDownloaderProgressBlock? = nil,</div><div class="line">                         completionHandler: ImageDownloaderCompletionHandler? = nil) -&gt; RetrieveImageDownloadTask?</div><div class="line"> &#123;</div><div class="line">     return downloadImage(with: url,</div><div class="line">                          retrieveImageTask: nil,</div><div class="line">                          options: options,</div><div class="line">                          progressBlock: progressBlock,</div><div class="line">                          completionHandler: completionHandler)</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">/// Protocol of `ImageDownloader`.</div><div class="line">public protocol ImageDownloaderDelegate: class &#123;</div><div class="line">    /**</div><div class="line">    Called when the `ImageDownloader` object successfully downloaded an image from specified URL.</div><div class="line">    </div><div class="line">    - parameter downloader: The `ImageDownloader` object finishes the downloading.</div><div class="line">    - parameter image:      Downloaded image.</div><div class="line">    - parameter url:        URL of the original request URL.</div><div class="line">    - parameter response:   The response object of the downloading process.</div><div class="line">    */</div><div class="line">    func imageDownloader(_ downloader: ImageDownloader, didDownload image: Image, for url: URL, with response: URLResponse?)</div><div class="line">    </div><div class="line">    </div><div class="line">    /**</div><div class="line">    Check if a received HTTP status code is valid or not. </div><div class="line">    By default, a status code between 200 to 400 (excluded) is considered as valid.</div><div class="line">    If an invalid code is received, the downloader will raise an .invalidStatusCode error.</div><div class="line">    It has a `userInfo` which includes this statusCode and localizedString error message.</div><div class="line">     </div><div class="line">    - parameter code: The received HTTP status code.</div><div class="line">    - parameter downloader: The `ImageDownloader` object asking for validate status code.</div><div class="line">     </div><div class="line">    - returns: Whether this HTTP status code is valid or not.</div><div class="line">     </div><div class="line">    - Note: If the default 200 to 400 valid code does not suit your need, </div><div class="line">            you can implement this method to change that behavior.</div><div class="line">    */</div><div class="line">    func isValidStatusCode(_ code: Int, for downloader: ImageDownloader) -&gt; Bool</div><div class="line">&#125;</div><div class="line"></div><div class="line">extension ImageDownloaderDelegate &#123;</div><div class="line">    public func imageDownloader(_ downloader: ImageDownloader, didDownload image: Image, for url: URL, with response: URLResponse?) &#123;&#125;</div><div class="line">    </div><div class="line">    public func isValidStatusCode(_ code: Int, for downloader: ImageDownloader) -&gt; Bool &#123;</div><div class="line">        return (200..&lt;400).contains(code)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里为止，<code>ImageDownloader</code> 的大部分功能都已经提及,还有一些细节<br>结构体 <code>RetrieveImageDownloadTask</code> 是对 <code>URLSessionDataTask</code> 的进一层包装<br>有 <code>cancel</code> 方法供外部调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public struct RetrieveImageDownloadTask &#123;</div><div class="line">    let internalTask: URLSessionDataTask</div><div class="line">    </div><div class="line">    /// Downloader by which this task is intialized.</div><div class="line">    public private(set) weak var ownerDownloader: ImageDownloader?</div><div class="line"></div><div class="line">    /**</div><div class="line">     Cancel this download task. It will trigger the completion handler with an NSURLErrorCancelled error.</div><div class="line">     */</div><div class="line">    public func cancel() &#123;</div><div class="line">        ownerDownloader?.cancelDownloadingTask(self)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /// The original request URL of this download task.</div><div class="line">    public var url: URL? &#123;</div><div class="line">        return internalTask.originalRequest?.url</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /// The relative priority of this download task. </div><div class="line">    /// It represents the `priority` property of the internal `NSURLSessionTask` of this download task.</div><div class="line">    /// The value for it is between 0.0~1.0. Default priority is value of 0.5.</div><div class="line">    /// See documentation on `priority` of `NSURLSessionTask` for more about it.</div><div class="line">    public var priority: Float &#123;</div><div class="line">        get &#123;</div><div class="line">            return internalTask.priority</div><div class="line">        &#125;</div><div class="line">        set &#123;</div><div class="line">            internalTask.priority = newValue</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ImageCache"><a href="#ImageCache" class="headerlink" title="ImageCache"></a>ImageCache</h2><p>在 <code>Kingfisher</code> 中， <code>ImageCache</code> 能够进行内存缓存和磁盘缓存。内存缓存由 <code>NSCache</code> 实现，磁盘缓存采用将image 转化成data ,加上FileManager操作文件完成。下面是主要实现功能</p>
<ul>
<li>缓存路径管理</li>
<li>缓存的添加与删除</li>
<li>缓存的获取</li>
<li>缓存的清除</li>
<li>缓存状态检查</li>
</ul>
<p>下面是 <code>ImageCache</code> 内部的属性： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">//Memory</div><div class="line">fileprivate let memoryCache = NSCache&lt;NSString, AnyObject&gt;()</div><div class="line"></div><div class="line">/// The largest cache cost of memory cache. The total cost is pixel count of </div><div class="line">/// all cached images in memory.</div><div class="line">/// Default is unlimited. Memory cache will be purged automatically when a </div><div class="line">/// memory warning notification is received.</div><div class="line">open var maxMemoryCost: UInt = 0 &#123;</div><div class="line">    didSet &#123;</div><div class="line">        self.memoryCache.totalCostLimit = Int(maxMemoryCost)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//Disk</div><div class="line">fileprivate let ioQueue: DispatchQueue</div><div class="line">fileprivate var fileManager: FileManager!</div><div class="line"></div><div class="line">///The disk cache location.</div><div class="line">open let diskCachePath: String</div><div class="line">  </div><div class="line">/// The default file extension appended to cached files.</div><div class="line">open var pathExtension: String?</div><div class="line"></div><div class="line">/// The longest time duration in second of the cache being stored in disk. </div><div class="line">/// Default is 1 week (60 * 60 * 24 * 7 seconds).</div><div class="line">open var maxCachePeriodInSecond: TimeInterval = 60 * 60 * 24 * 7 //Cache exists for 1 week</div><div class="line"></div><div class="line">/// The largest disk size can be taken for the cache. It is the total </div><div class="line">/// allocated size of cached files in bytes.</div><div class="line">/// Default is no limit.</div><div class="line">open var maxDiskCacheSize: UInt = 0</div><div class="line"></div><div class="line">fileprivate let processQueue: DispatchQueue</div><div class="line"></div><div class="line">/// The default cache.</div><div class="line">public static let `default` = ImageCache(name: &quot;default&quot;)</div><div class="line"></div><div class="line">/// Closure that defines the disk cache path from a given path and cacheName.</div><div class="line">public typealias DiskCachePathClosure = (String?, String) -&gt; String</div><div class="line"></div><div class="line">/// The default DiskCachePathClosure</div><div class="line">public final class func defaultDiskCachePathClosure(path: String?, cacheName: String) -&gt; String &#123;</div><div class="line">    let dstPath = path ?? NSSearchPathForDirectoriesInDomains(.cachesDirectory, .userDomainMask, true).first!</div><div class="line">    return (dstPath as NSString).appendingPathComponent(cacheName)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中: <code>memoryCache</code> 用来管理内存缓存，<code>ioQueue</code> 用来进行硬盘队列操作。由于硬盘存取操作相比于内存存取耗时，避免造成线程阻塞需单独开辟线程进行相应操作。<code>fileManager</code> 用于文件管理。 <code>diskCachePath</code> 用于设置文件的存储路径。 <code>maxCachePeriodInSecond</code> ,最大的磁盘缓存时间，默认一周 <code>maxDiskCacheSize</code> 最大的磁盘缓存大小。 <code>processQueue</code> 用于执行图片的 <code>decode</code> 操作。<code>default</code> 为  <code>ImageCache</code> 类的单例，在Swift 中，调用 <code>static let</code> 可以直接创建一个单例，系统会自动调用 <code>dispatch_once</code>。</p>
<h3 id="缓存路径相关的几个方法"><a href="#缓存路径相关的几个方法" class="headerlink" title="缓存路径相关的几个方法"></a>缓存路径相关的几个方法</h3><ul>
<li>根据key,serializer, options获取磁盘图片</li>
<li>根据key获取磁盘图片数据</li>
<li>根据key 获取md5加密字符串</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">extension ImageCache &#123;</div><div class="line">  </div><div class="line">    func diskImage(forComputedKey key: String, serializer: CacheSerializer, options: KingfisherOptionsInfo) -&gt; Image? &#123;</div><div class="line">        if let data = diskImageData(forComputedKey: key) &#123;</div><div class="line">            return serializer.image(with: data, options: options)</div><div class="line">        &#125; else &#123;</div><div class="line">            return nil</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    func diskImageData(forComputedKey key: String) -&gt; Data? &#123;</div><div class="line">        let filePath = cachePath(forComputedKey: key)</div><div class="line">        return (try? Data(contentsOf: URL(fileURLWithPath: filePath)))</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    func cacheFileName(forComputedKey key: String) -&gt; String &#123;</div><div class="line">        if let ext = self.pathExtension &#123;</div><div class="line">          return (key.kf.md5 as NSString).appendingPathExtension(ext)!</div><div class="line">        &#125;</div><div class="line">        return key.kf.md5</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="缓存的添加与删除"><a href="#缓存的添加与删除" class="headerlink" title="缓存的添加与删除"></a>缓存的添加与删除</h3><p>主要外部调用方法 <code>store</code> ,首先对传入的 URL Key 和 processorIdentifier 做简单拼接成computedKey，设置内存缓存。然后根据是否磁盘缓存 进一步处理，其中调用 <code>CacheSerializer</code> 的  <code>func data(with image: Image, original: Data?) -&gt; Data?</code> 方法,根据Data 获取图片类型，将image序列化成data 存入文件，其中path 是computedKey经过md5加密获得</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">open func store(_ image: Image,</div><div class="line">                    original: Data? = nil,</div><div class="line">                    forKey key: String,</div><div class="line">                    processorIdentifier identifier: String = &quot;&quot;,</div><div class="line">                    cacheSerializer serializer: CacheSerializer = DefaultCacheSerializer.default,</div><div class="line">                    toDisk: Bool = true,</div><div class="line">                    completionHandler: (() -&gt; Void)? = nil)</div><div class="line">  &#123;</div><div class="line">      //内存缓存</div><div class="line">      let computedKey = key.computedKey(with: identifier)</div><div class="line">      memoryCache.setObject(image, forKey: computedKey as NSString, cost: image.kf.imageCost)</div><div class="line"></div><div class="line">      func callHandlerInMainQueue() &#123;</div><div class="line">          if let handler = completionHandler &#123;</div><div class="line">              DispatchQueue.main.async &#123;</div><div class="line">                  handler()</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">      if toDisk &#123;</div><div class="line">         需要磁盘缓存</div><div class="line">          ioQueue.async &#123;</div><div class="line">              将image 序列化成 data</div><div class="line">              if let data = serializer.data(with: image, original: original) &#123;</div><div class="line">                  if !self.fileManager.fileExists(atPath: self.diskCachePath) &#123;</div><div class="line">                      do &#123;</div><div class="line">                          不存在磁盘缓存文件夹 创建 默认在 Library/Cache/com.onevcat.Kingfisher.ImageCache.default</div><div class="line">                          try self.fileManager.createDirectory(atPath: self.diskCachePath, withIntermediateDirectories: true, attributes: nil)</div><div class="line">                      &#125; catch _ &#123;&#125;</div><div class="line">                  &#125;</div><div class="line">                  磁盘缓存</div><div class="line">                  self.fileManager.createFile(atPath: self.cachePath(forComputedKey: computedKey), contents: data, attributes: nil)</div><div class="line">              &#125;</div><div class="line">              callHandlerInMainQueue()</div><div class="line">          &#125;</div><div class="line">      &#125; else &#123;</div><div class="line">          callHandlerInMainQueue()</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<ul>
<li>根据存入的key值移除缓存图片，如果需要移除磁盘缓存，删除对应文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">open func removeImage(forKey key: String,</div><div class="line">                        processorIdentifier identifier: String = &quot;&quot;,</div><div class="line">                        fromDisk: Bool = true,</div><div class="line">                        completionHandler: (() -&gt; Void)? = nil)</div><div class="line">  &#123;</div><div class="line">      根据key移除内存缓存</div><div class="line">      let computedKey = key.computedKey(with: identifier)</div><div class="line">      memoryCache.removeObject(forKey: computedKey as NSString)</div><div class="line">      </div><div class="line">      func callHandlerInMainQueue() &#123;</div><div class="line">          if let handler = completionHandler &#123;</div><div class="line">              DispatchQueue.main.async &#123;</div><div class="line">                  handler()</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">      if fromDisk &#123;</div><div class="line">          ioQueue.async&#123;</div><div class="line">              do &#123;</div><div class="line">                  根据key移除磁盘缓存</div><div class="line">                  try self.fileManager.removeItem(atPath: self.cachePath(forComputedKey: computedKey))</div><div class="line">              &#125; catch _ &#123;&#125;</div><div class="line">              callHandlerInMainQueue()</div><div class="line">          &#125;</div><div class="line">      &#125; else &#123;</div><div class="line">          callHandlerInMainQueue()</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h3 id="缓存的获取"><a href="#缓存的获取" class="headerlink" title="缓存的获取"></a>缓存的获取</h3><p>根据 <code>key</code> 获得缓存图片 首先从内存缓存中获取，如果无内存缓存，再判断磁盘缓存。如果有，从磁盘中获取缓存文件，将图片 <code>data</code> 反序列化成 <code>image</code> ，在返回之前判断了是否需要后台编码，做了内存缓存。这里返回的<code>RetrieveImageDiskTask</code> 是一个 <code>DispatchWorkItem</code> ,相当于OC的 <code>dispatch_block_t</code> ，它定义了获取磁盘缓存并进行内存缓存的操作闭包，放在ioQueue中异步执行，确保了外部在操作过程中一直持有该缓存操作，相当于 <code>ImageDownloader</code> 的 <code>RetrieveImageDownloadTask</code> ,并且在返回之前都将sSelf置为nil，释放了内存。因为该闭包属于逃逸闭包，必需在闭包中显式地引用self 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">open func retrieveImage(forKey key: String,</div><div class="line">                              options: KingfisherOptionsInfo?,</div><div class="line">                    completionHandler: ((Image?, CacheType) -&gt; ())?) -&gt; RetrieveImageDiskTask?</div><div class="line">   &#123;</div><div class="line">       // No completion handler. Not start working and early return.</div><div class="line">       guard let completionHandler = completionHandler else &#123;</div><div class="line">           return nil</div><div class="line">       &#125;</div><div class="line">       </div><div class="line">       var block: RetrieveImageDiskTask?</div><div class="line">       let options = options ?? KingfisherEmptyOptionsInfo</div><div class="line">       首先判断内存缓存是否存在</div><div class="line">       if let image = self.retrieveImageInMemoryCache(forKey: key, options: options) &#123;</div><div class="line">           options.callbackDispatchQueue.safeAsync &#123;</div><div class="line">               completionHandler(image, .memory)</div><div class="line">           &#125;</div><div class="line">       &#125; else &#123;</div><div class="line">           var sSelf: ImageCache! = self</div><div class="line">           block = DispatchWorkItem(block: &#123;</div><div class="line">               // Begin to load image from disk</div><div class="line">               if let image = sSelf.retrieveImageInDiskCache(forKey: key, options: options) &#123;</div><div class="line">                   if options.backgroundDecode &#123;</div><div class="line">                       sSelf.processQueue.async &#123;</div><div class="line">                           let result = image.kf.decoded(scale: options.scaleFactor)</div><div class="line">                           内存缓存</div><div class="line">                           sSelf.store(result,</div><div class="line">                                       forKey: key,</div><div class="line">                                       processorIdentifier: options.processor.identifier,</div><div class="line">                                       cacheSerializer: options.cacheSerializer,</div><div class="line">                                       toDisk: false,</div><div class="line">                                       completionHandler: nil)</div><div class="line">                           </div><div class="line">                           options.callbackDispatchQueue.safeAsync &#123;</div><div class="line">                               completionHandler(result, .memory)</div><div class="line">                               sSelf = nil</div><div class="line">                           &#125;</div><div class="line">                       &#125;</div><div class="line">                   &#125; else &#123;</div><div class="line">                       内存缓存</div><div class="line">                       sSelf.store(image,</div><div class="line">                                   forKey: key,</div><div class="line">                                   processorIdentifier: options.processor.identifier,</div><div class="line">                                   cacheSerializer: options.cacheSerializer,</div><div class="line">                                   toDisk: false,</div><div class="line">                                   completionHandler: nil</div><div class="line">                       )</div><div class="line">                       options.callbackDispatchQueue.safeAsync &#123;</div><div class="line">                           completionHandler(image, .disk)</div><div class="line">                           sSelf = nil</div><div class="line">                       &#125;</div><div class="line">                   &#125;</div><div class="line">               &#125; else &#123;</div><div class="line">                   // No image found from either memory or disk</div><div class="line">                   没有磁盘缓存</div><div class="line">                   options.callbackDispatchQueue.safeAsync &#123;</div><div class="line">                       completionHandler(nil, .none)</div><div class="line">                       sSelf = nil</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">           &#125;)</div><div class="line">           </div><div class="line">           sSelf.ioQueue.async(execute: block!)</div><div class="line">       &#125;</div><div class="line">   </div><div class="line">       return block</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li>从内存中获取图片</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">open func retrieveImageInMemoryCache(forKey key: String, options: KingfisherOptionsInfo? = nil) -&gt; Image? &#123;</div><div class="line">    let options = options ?? KingfisherEmptyOptionsInfo</div><div class="line">    let computedKey = key.computedKey(with: options.processor.identifier)</div><div class="line">    </div><div class="line">    return memoryCache.object(forKey: computedKey as NSString) as? Image</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>从磁盘中获取图片</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">open func retrieveImageInDiskCache(forKey key: String, options: KingfisherOptionsInfo? = nil) -&gt; Image? &#123;</div><div class="line">    </div><div class="line">    let options = options ?? KingfisherEmptyOptionsInfo</div><div class="line">    let computedKey = key.computedKey(with: options.processor.identifier)</div><div class="line">    </div><div class="line">    return diskImage(forComputedKey: computedKey, serializer: options.cacheSerializer, options: options)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="缓存的清除"><a href="#缓存的清除" class="headerlink" title="缓存的清除"></a>缓存的清除</h3><ul>
<li>手动清除所有内存缓存和磁盘缓存</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">@objc public func clearMemoryCache() &#123;</div><div class="line">    memoryCache.removeAllObjects()</div><div class="line"></div><div class="line">/**</div><div class="line">Clear disk cache. This is an async operation.</div><div class="line"></div><div class="line">- parameter completionHander: Called after the operation completes.</div><div class="line">*/</div><div class="line">open func clearDiskCache(completion handler: (()-&gt;())? = nil) &#123;</div><div class="line">    ioQueue.async &#123;</div><div class="line">        do &#123;</div><div class="line">            try self.fileManager.removeItem(atPath: self.diskCachePath)</div><div class="line">            try self.fileManager.createDirectory(atPath: self.diskCachePath, withIntermediateDirectories: true, attributes: nil)</div><div class="line">        &#125; catch _ &#123; &#125;</div><div class="line">        </div><div class="line">        if let handler = handler &#123;</div><div class="line">            DispatchQueue.main.async &#123;</div><div class="line">                handler()</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>当应用程序在进入后台的时候，可以自动检测过期缓存文件，并在后台完成清理操作，实现代码如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">@objc public func backgroundCleanExpiredDiskCache() &#123;</div><div class="line">    // if &apos;sharedApplication()&apos; is unavailable, then return</div><div class="line">    guard let sharedApplication = Kingfisher&lt;UIApplication&gt;.shared else &#123; return &#125;</div><div class="line"></div><div class="line">    func endBackgroundTask(_ task: inout UIBackgroundTaskIdentifier) &#123;</div><div class="line">        sharedApplication.endBackgroundTask(task)</div><div class="line">        task = UIBackgroundTaskInvalid</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    var backgroundTask: UIBackgroundTaskIdentifier!</div><div class="line">    backgroundTask = sharedApplication.beginBackgroundTask &#123;</div><div class="line">        endBackgroundTask(&amp;backgroundTask!)</div><div class="line">    &#125;</div><div class="line">    //清除过期的磁盘缓存</div><div class="line">    cleanExpiredDiskCache &#123;</div><div class="line">        endBackgroundTask(&amp;backgroundTask!)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 获取过期的 <code>URL</code> 数组，磁盘缓存大小和缓存文件字典, 进行缓存删除操作。 通过 <code>FileManager</code> 的 <code>enumerator</code> 方法遍历出所有缓存文件，如果文件最后一次访问日期比当前时间减去一周时间还要早，将该文件<code>fileUrl</code> 添加到 <code>urlsToDelete</code> 数组。计算缓存文件大小，以 <code>fileUrl</code> 为 <code>key</code> ， <code>resourceValues</code> 为 <code>value</code> ,存入 <code>cachedFiles</code>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">fileprivate func travelCachedFiles(onlyForCacheSize: Bool) -&gt; (urlsToDelete: [URL],diskCacheSize: UInt, cachedFiles: [URL: URLResourceValues]) &#123;</div><div class="line">       </div><div class="line">       let diskCacheURL = URL(fileURLWithPath: diskCachePath)</div><div class="line">       let resourceKeys: Set&lt;URLResourceKey&gt; = [.isDirectoryKey, .contentAccessDateKey, .totalFileAllocatedSizeKey]</div><div class="line">       //过期日期</div><div class="line">       let expiredDate = Date(timeIntervalSinceNow: -maxCachePeriodInSecond)</div><div class="line">       // 缓存字典 URL : ResourceValue</div><div class="line">       var cachedFiles = [URL: URLResourceValues]()</div><div class="line">       var urlsToDelete = [URL]()</div><div class="line">       var diskCacheSize: UInt = 0</div><div class="line">       </div><div class="line">       if let fileEnumerator = self.fileManager.enumerator(at: diskCacheURL, includingPropertiesForKeys: Array(resourceKeys), options: FileManager.DirectoryEnumerationOptions.skipsHiddenFiles, errorHandler: nil),</div><div class="line">          let urls = fileEnumerator.allObjects as? [URL]</div><div class="line">       &#123;</div><div class="line">           for fileUrl in urls &#123;</div><div class="line">               </div><div class="line">               do &#123;</div><div class="line">                   let resourceValues = try fileUrl.resourceValues(forKeys: resourceKeys)</div><div class="line">                   // If it is a Directory. Continue to next file URL.</div><div class="line">                   if resourceValues.isDirectory == true &#123;</div><div class="line">                       continue</div><div class="line">                   &#125;</div><div class="line">                   </div><div class="line">                   if !onlyForCacheSize &#123;</div><div class="line">                       // If this file is expired, add it to URLsToDelete</div><div class="line">                       if let lastAccessData = resourceValues.contentAccessDate &#123;</div><div class="line">                           if (lastAccessData as NSDate).laterDate(expiredDate) == expiredDate &#123;</div><div class="line">                               //添加过期URL到删除数组</div><div class="line">                               urlsToDelete.append(fileUrl)</div><div class="line">                               continue</div><div class="line">                           &#125;</div><div class="line">                       &#125;</div><div class="line">                   &#125;</div><div class="line"></div><div class="line">                   if let fileSize = resourceValues.totalFileAllocatedSize &#123;</div><div class="line">                       //更新缓存大小</div><div class="line">                       diskCacheSize += UInt(fileSize)</div><div class="line">                       if !onlyForCacheSize &#123;</div><div class="line">                           // 缓存文件字典对应</div><div class="line">                           cachedFiles[fileUrl] = resourceValues</div><div class="line">                       &#125;</div><div class="line">                   &#125;</div><div class="line">               &#125; catch _ &#123; &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       </div><div class="line">       return (urlsToDelete, diskCacheSize, cachedFiles)</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>根据上面获取的 <code>urlsToDelete</code> 数组， <code>diskCacheSize</code> 磁盘缓存大小和 <code>cachedFiles</code> 字典，删除过期缓存 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">open func cleanExpiredDiskCache(completion handler: (()-&gt;())? = nil) &#123;</div><div class="line">      </div><div class="line">      // Do things in cocurrent io queue</div><div class="line">      ioQueue.async &#123;</div><div class="line">          </div><div class="line">          var (URLsToDelete, diskCacheSize, cachedFiles) = self.travelCachedFiles(onlyForCacheSize: false)</div><div class="line">          //清除过期的磁盘缓存 根据资源最后一次访问的时间和 当前时间减去一周时间（自定义最长缓存存在时间）比较判断是否过期</div><div class="line">          for fileURL in URLsToDelete &#123;</div><div class="line">              do &#123;</div><div class="line">                  try self.fileManager.removeItem(at: fileURL)</div><div class="line">              &#125; catch _ &#123; &#125;</div><div class="line">          &#125;</div><div class="line">          //磁盘缓存大小超过自定义最大缓存</div><div class="line">          if self.maxDiskCacheSize &gt; 0 &amp;&amp; diskCacheSize &gt; self.maxDiskCacheSize &#123;</div><div class="line">              //计划清除到最大缓存的一半</div><div class="line">              let targetSize = self.maxDiskCacheSize / 2</div><div class="line">                  </div><div class="line">              // Sort files by last modify date. We want to clean from the oldest files.</div><div class="line">              //清除访问次数少的文件</div><div class="line">              let sortedFiles = cachedFiles.keysSortedByValue &#123;</div><div class="line">                  resourceValue1, resourceValue2 -&gt; Bool in</div><div class="line">                  </div><div class="line">                  if let date1 = resourceValue1.contentAccessDate,</div><div class="line">                     let date2 = resourceValue2.contentAccessDate</div><div class="line">                  &#123;</div><div class="line">                      return date1.compare(date2) == .orderedAscending</div><div class="line">                  &#125;</div><div class="line">                  </div><div class="line">                  // Not valid date information. This should not happen. Just in case.</div><div class="line">                  return true</div><div class="line">              &#125;</div><div class="line">              </div><div class="line">              for fileURL in sortedFiles &#123;</div><div class="line">                  </div><div class="line">                  do &#123;</div><div class="line">                      try self.fileManager.removeItem(at: fileURL)</div><div class="line">                  &#125; catch &#123; &#125;</div><div class="line">                      </div><div class="line">                  URLsToDelete.append(fileURL)</div><div class="line">                  </div><div class="line">                  if let fileSize = cachedFiles[fileURL]?.totalFileAllocatedSize &#123;</div><div class="line">                      diskCacheSize -= UInt(fileSize)</div><div class="line">                  &#125;</div><div class="line">                  //达到指定目标 返回</div><div class="line">                  if diskCacheSize &lt; targetSize &#123;</div><div class="line">                      break</div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">              </div><div class="line">          DispatchQueue.main.async &#123;</div><div class="line">              </div><div class="line">              if URLsToDelete.count != 0 &#123;</div><div class="line">                  let cleanedHashes = URLsToDelete.map &#123; $0.lastPathComponent &#125;</div><div class="line">                  NotificationCenter.default.post(name: .KingfisherDidCleanDiskCache, object: self, userInfo: [KingfisherDiskCacheCleanedHashKey: cleanedHashes])</div><div class="line">              &#125;</div><div class="line">              </div><div class="line">              handler?()</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h3 id="缓存的状态检查"><a href="#缓存的状态检查" class="headerlink" title="缓存的状态检查"></a>缓存的状态检查</h3><ul>
<li>缓存类型结构体</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public struct CacheCheckResult &#123;</div><div class="line">      public let cached: Bool</div><div class="line">      public let cacheType: CacheType?</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<ul>
<li>根据key判断是否存在缓存以及缓存图片类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">open func isImageCached(forKey key: String, processorIdentifier identifier: String = &quot;&quot;) -&gt; CacheCheckResult &#123;</div><div class="line">    </div><div class="line">    let computedKey = key.computedKey(with: identifier)</div><div class="line">    </div><div class="line">    if memoryCache.object(forKey: computedKey as NSString) != nil &#123;</div><div class="line">        return CacheCheckResult(cached: true, cacheType: .memory)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    let filePath = cachePath(forComputedKey: computedKey)</div><div class="line">    </div><div class="line">    var diskCached = false</div><div class="line">    ioQueue.sync &#123;</div><div class="line">        diskCached = fileManager.fileExists(atPath: filePath)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if diskCached &#123;</div><div class="line">        return CacheCheckResult(cached: true, cacheType: .disk)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return CacheCheckResult(cached: false, cacheType: nil)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>根据key，processorIdentifier查找缓存文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">Get the hash for the key. This could be used for matching files.</div><div class="line"></div><div class="line">- parameter key:        The key which is used for caching.</div><div class="line">- parameter identifier: The identifier of processor used. If you are using a processor for the image, pass the identifier of processor to it.</div><div class="line"></div><div class="line"> - returns: Corresponding hash.</div><div class="line">*/</div><div class="line">open func hash(forKey key: String, processorIdentifier identifier: String = &quot;&quot;) -&gt; String &#123;</div><div class="line">    let computedKey = key.computedKey(with: identifier)</div><div class="line">    return cacheFileName(forComputedKey: computedKey)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>计算缓存大小</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">Calculate the disk size taken by cache. </div><div class="line">It is the total allocated size of the cached files in bytes.</div><div class="line"></div><div class="line">- parameter completionHandler: Called with the calculated size when finishes.</div><div class="line">*/</div><div class="line">open func calculateDiskCacheSize(completion handler: @escaping ((_ size: UInt) -&gt; ())) &#123;</div><div class="line">    ioQueue.async &#123;</div><div class="line">        let (_, diskCacheSize, _) = self.travelCachedFiles(onlyForCacheSize: true)</div><div class="line">        DispatchQueue.main.async &#123;</div><div class="line">            handler(diskCacheSize)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>根据key，identifier获取加密后的缓存路径</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">Get the cache path for the key.</div><div class="line">It is useful for projects with UIWebView or anyone that needs access to the local file path.</div><div class="line">  </div><div class="line">- Note: This method does not guarantee there is an image already cached in the path. It just returns the path</div><div class="line">  that the image should be.</div><div class="line">  You could use `isImageCached(forKey:)` method to check whether the image is cached under that key.</div><div class="line">*/</div><div class="line">open func cachePath(forKey key: String, processorIdentifier identifier: String = &quot;&quot;) -&gt; String &#123;</div><div class="line">    let computedKey = key.computedKey(with: identifier)</div><div class="line">    return cachePath(forComputedKey: computedKey)</div><div class="line">&#125;</div><div class="line">open func cachePath(forComputedKey key: String) -&gt; String &#123;</div><div class="line">    let fileName = cacheFileName(forComputedKey: key)</div><div class="line">    return (diskCachePath as NSString).appendingPathComponent(fileName)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="CacheSerializer"><a href="#CacheSerializer" class="headerlink" title="CacheSerializer"></a>CacheSerializer</h3><p>该类用于将磁盘图片数据反序列化成图片对象以及将图片对象序列化成图片数据。具体功能由 <code>Image</code> 文件实现<br> <code>Image</code> 序列化 <code>Data</code> 。通过 <code>Data</code> 获取图片 <code>format</code> ,返回不同格式下图片。能实现 <code>PNG</code> ，<code>JPEG</code> ，<code>GIF</code> 图片格式，其他图片格式默认返回 <code>PNG</code> 格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public func data(with image: Image, original: Data?) -&gt; Data? &#123;</div><div class="line">       let imageFormat = original?.kf.imageFormat ?? .unknown</div><div class="line">       </div><div class="line">       let data: Data?</div><div class="line">       switch imageFormat &#123;</div><div class="line">       case .PNG: data = image.kf.pngRepresentation()</div><div class="line">       case .JPEG: data = image.kf.jpegRepresentation(compressionQuality: 1.0)</div><div class="line">       case .GIF: data = image.kf.gifRepresentation()</div><div class="line">       case .unknown: data = original ?? image.kf.normalized.kf.pngRepresentation()</div><div class="line">       &#125;</div><div class="line">       </div><div class="line">       return data</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p><code>Data</code> 序列化成 <code>Image</code>。 如果是 <code>GIF</code> 图片， <code>preloadAllGIFData</code> 用于判断图片显示方式。 false： 不会加载所有 <code>GIF</code> 图片数据，只显示 <code>GIF</code> 中的第一张图片，true：将所有图片数据加载到内存，显示 <code>GIF</code>动态图片 </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public func image(with data: Data, options: KingfisherOptionsInfo?) -&gt; Image? &#123;</div><div class="line">        let scale = (options ?? KingfisherEmptyOptionsInfo).scaleFactor</div><div class="line">        let preloadAllGIFData = (options ?? KingfisherEmptyOptionsInfo).preloadAllGIFData</div><div class="line">        </div><div class="line">        return Kingfisher&lt;Image&gt;.image(data: data, scale: scale, preloadAllGIFData: preloadAllGIFData)</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
  
  
</search>
